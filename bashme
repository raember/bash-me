#!/bin/bash -
#==============================================================================
#title          :bashme.sh
#description    :A bash template which manages vital mechanisms for bash
#                scripting.
#author         :Raphael Emberger
#date           :20180612
#version        :0.1    
#usage          :./bashme.sh
#notes          :
#bash_version   :4.4.12(1)-release
#==============================================================================



###############################################################################
#                                  LOGGING                                    #
###############################################################################
# Constants
declare -ri LL_TRACE=0
declare -ri LL_DEBUG=1
declare -ri LL_INFO=2
declare -ri LL_WARN=3
declare -ri LL_ERROR=4
declare -ri LL_FATAL=5
declare -ri LL_QUIET=6

# Variables
declare -i loglevel=$LL_INFO
declare logfile="./$(command -p basename "$0").log"
declare log2file=''
declare log2std=1

##
# Logs a message according to its log level.
# Globals:
#   BASH_LINENO
#   FUNCNAME
#   BASH_SOURCE
#   LL_ERROR
#   fnt_reset
#   log2std
#   log2file
#   logfile
# Arguments:
#   Color
#   Log level
#   Literal log level
#   Log message
# Returns:
#   None
#
function log() {
  local lineno="${BASH_LINENO[$((${#BASH_LINENO} - 1))]}"
  local location=" ${FUNCNAME[2]}(): "
  local logmsg="$(command -p date '+%Y-%M-%d %H:%m:%S') $3($lineno)$location$4"
  if [[ -n "$log2std" ]]; then
    if (( $2 >= $LL_ERROR )); then
      command -p echo -e "$1$logmsg$fnt_reset" >&2
    else
      command -p echo -e "$1$logmsg$fnt_reset"
    fi
  fi
  [[ -n "$log2file" ]] && echo "$logmsg" >> $logfile
  return $EX_OK
}

##
# Logs a message on the trace level.
# Globals:
#   LL_TRACE
#   loglevel
#   fg_light_gray
# Arguments:
#   Log message
# Returns:
#   None
#
function trace() {
  [[ $loglevel -gt $LL_TRACE ]] && return $EX_OK
  log "$fg_light_gray" $LL_TRACE '[TRACE]' "$1"
  return $EX_OK
}

##
# Logs a message on the debug level.
# Globals:
#   LL_DEBUG
#   loglevel
#   fg_light_gray
# Arguments:
#   Log message
# Returns:
#   None
#
function debug() {
  [[ $loglevel -gt $LL_DEBUG ]] && return $EX_OK
  log "$fg_light_gray" $LL_DEBUG '[DEBUG]' "$1"
  return $EX_OK
}

##
# Logs a message on the info level.
# Globals:
#   LL_INFO
#   loglevel
#   fg_default
# Arguments:
#   Log message
# Returns:
#   None
#
function info() {
  [[ $loglevel -gt $LL_INFO ]] && return $EX_OK
  log "$fg_default" $LL_INFO '[INFO] ' "$1"
  return $EX_OK
}

##
# Logs a message on the warn level.
# Globals:
#   LL_WARN
#   loglevel
#   fg_yellow
# Arguments:
#   Log message
# Returns:
#   None
#
function warn() {
  [[ $loglevel -gt $LL_WARN ]] && return $EX_OK
  log "$fg_yellow" $LL_WARN '[WARN] ' "$1"
  return $EX_OK
}

##
# Logs a message on the error level.
# Globals:
#   LL_ERROR
#   loglevel
#   fg_light_red
# Arguments:
#   Log message
# Returns:
#   None
#
function error() {
  [[ $loglevel -gt $LL_ERROR ]] && return $EX_OK
  log "$fg_light_red" $LL_ERROR '[ERROR]' "$1"
  return $EX_OK
}

##
# Logs a message on the fatal level.
# Globals:
#   LL_FATAL
#   loglevel
#   fg_red
# Arguments:
#   Log message
# Returns:
#   None
#
function fatal() {
  [[ $loglevel -gt $LL_FATAL ]] && return $EX_OK
  log "$fg_red" $LL_FATAL '[FATAL]' "$1"
  return $EX_OK
}

##
# A makeshift function to cover logging the access to not yet implemented
# functionality.
# Globals:
#   LL_FATAL
#   loglevel
#   fg_red
# Arguments:
#   None
# Returns:
#   None
#
function niy() {
  fatal "Not implemented yet!"
  return $EX_OK
}



###############################################################################
#                                RETURN VALUE                                 #
###############################################################################
# Constants
declare -ri EX_OK=0
declare -ri EX_ERR=1
declare -ri EX_MISSUSE=2
declare -ri EX_CANNOTEXEC=126
declare -ri EX_CMDNOTFOUND=127
declare -ri EX_INVALARG=128
declare -ri EX_FATAL_BASE=128
declare -ri EX_INT=130
declare -ri EX_OUTOFRANGE=255

##
# Checks the last return value and writes logs.
# Globals:
#   None
# Arguments:
#   Last return value ($?)
# Returns:
#   Last return value ($?)
#
function check_retval() {
  trace "Checking return value: $1"
  local retval="$1"
  local excode="return value $retval: "
  if [[ $retval -gt 64 ]] && [[ $retval -lt 114 ]]; then
    debug "${excode}Custom C/C++ return code according to /usr/include/sysexits.h detected."
  fi
  if [[ $retval -gt 128 ]] && [[ $retval -lt 166 ]]; then
    debug "${excode}Custom fatal return value detected."
  fi
  case $retval in
    $EX_OK)
      debug "${excode}Code exited normally."
      ;;
    $EX_ERR)
      debug "${excode}Catchall for general errors. Miscellaneous errors, such as 'divide by zero' and other impermissible operations."
      ;;
    $EX_MISSUSE)
      debug "${excode}Misuse of shell builtins. Missing keyword or command or permission problem."
      ;;
    $EX_CANNOTEXEC)
      debug "${excode}Command invoked cannot execute. Permission problem or command is not an executable."
      ;;
    $EX_CMDNOTFOUND)
      debug "${excode}Command not found. Possible problem with \$PATH or a typo."
      ;;
    $EX_INVALARG)
      debug "${excode}Invalid argument to exit. exit takes only integer args in the range 0 - 255."
      ;;
    $EX_INT)
      debug "${excode}Command terminated by Control-C."
      ;;
    $EX_OUTOFRANGE)
      debug "${excode}Exit status out of range. exit takes only integer args in the range 0 - 255."
      ;;
    ?)
      warn "Could not categorize return value $retval appropriately."
  esac
  return $retval
}




###############################################################################
#                            COLORS AND FORMATTING                            #
###############################################################################
# Constants
readonly fg_default='\033[39m'
readonly fg_black='\033[30m'
readonly fg_red='\033[31m'
readonly fg_green='\033[32m'
readonly fg_yellow='\033[33m'
readonly fg_blue='\033[34m'
readonly fg_magenta='\033[35m'
readonly fg_cyan='\033[36m'
readonly fg_light_gray='\033[37m'
readonly fg_dark_gray='\033[90m'
readonly fg_light_red='\033[91m'
readonly fg_light_green='\033[92m'
readonly fg_light_yellow='\033[93m'
readonly fg_light_blue='\033[94m'
readonly fg_light_magenta='\033[95m'
readonly fg_light_cyan='\033[96m'
readonly fg_white='\033[97m'

readonly bg_default='\033[49m'
readonly bg_black='\033[40m'
readonly bg_red='\033[41m'
readonly bg_green='\033[42m'
readonly bg_yellow='\033[43m'
readonly bg_blue='\033[44m'
readonly bg_magenta='\033[45m'
readonly bg_cyan='\033[46m'
readonly bg_light_gray='\033[47m'
readonly bg_dark_gray='\033[100m'
readonly bg_light_red='\033[101m'
readonly bg_light_green='\033[102m'
readonly bg_light_yellow='\033[103m'
readonly bg_light_blue='\033[104m'
readonly bg_light_magenta='\033[105m'
readonly bg_light_cyan='\033[106m'
readonly bg_white='\033[107m'

readonly fnt_bold='\033[1m'
readonly fnt_dim='\033[2m'
readonly fnt_italic='\033[3m'
readonly fnt_underline='\033[4m'
readonly fnt_blink='\033[5m'
readonly fnt_overline='\033[6m'
readonly fnt_reverse='\033[7m'
readonly fnt_hidden='\033[8m'
readonly fnt_strikeout='\033[9m'

readonly fnt_no_bold='\033[21m'
readonly fnt_no_dim='\033[22m'
readonly fnt_no_italic='\033[23m'
readonly fnt_no_underline='\033[24m'
readonly fnt_no_blink='\033[25m'
readonly fnt_no_overline='\033[26m'
readonly fnt_no_reverse='\033[27m'
readonly fnt_no_hidden='\033[28m'
readonly fnt_no_strikeout='\033[29m'

readonly fnt_reset='\033[0m'

##
# Prints a table of all the available formats.
# Globals:
#   fnt_bold
#   fnt_dim
#   fnt_italic
#   fnt_underline
#   fnt_blink
#   fnt_overline
#   fnt_reverse
#   fnt_hidden
#   fnt_strikeout
#   fnt_no_bold
#   fnt_no_dim
#   fnt_no_italic
#   fnt_no_underline
#   fnt_no_blink
#   fnt_no_overline
#   fnt_no_reverse
#   fnt_no_hidden
#   fnt_no_strikeout
#   fnt_reset
# Arguments:
#   None
# Returns:
#   None
#
function formatting_test() {
  trace 'Printing formatting table.'
  command -p echo -e "Bold:      ${fnt_bold}Bold${fnt_no_bold}.      No Bold${fnt_reset}."
  command -p echo -e "Dim:       ${fnt_dim}Dim${fnt_no_dim}.       No Dim${fnt_reset}."
  command -p echo -e "Italic:    ${fnt_italic}Italic${fnt_no_italic}.    No Italic${fnt_reset}."
  command -p echo -e "Underline: ${fnt_underline}Underline${fnt_no_underline}. No Underline${fnt_reset}."
  command -p echo -e "Blink:     ${fnt_blink}Blink${fnt_no_blink}.     No Blink${fnt_reset}."
  command -p echo -e "Overline:  ${fnt_overline}Overline${fnt_no_overline}.  No Overline${fnt_reset}."
  command -p echo -e "Reverse:   ${fnt_reverse}Reverse${fnt_no_reverse}.   No Reverse${fnt_reset}."
  command -p echo -e "Hidden:    ${fnt_hidden}Hidden${fnt_no_hidden}.    No Hidden${fnt_reset}."
  command -p echo -e "Strikeout: ${fnt_strikeout}Strikeout${fnt_no_strikeout}. No Strikeout${fnt_reset}."
  return $EX_OK
}

##
# Prints a table of all the available colors.
# Globals:
#   fg_default
#   fg_black
#   fg_red
#   fg_green
#   fg_yellow
#   fg_blue
#   fg_magenta
#   fg_cyan
#   fg_light_gray
#   fg_dark_gray
#   fg_light_red
#   fg_light_green
#   fg_light_yellow
#   fg_light_blue
#   fg_light_magenta
#   fg_light_cyan
#   fg_white
#   bg_default
#   bg_black
#   bg_red
#   bg_green
#   bg_yellow
#   bg_blue
#   bg_magenta
#   bg_cyan
#   bg_light_gray
#   bg_dark_gray
#   bg_light_red
#   bg_light_green
#   bg_light_yellow
#   bg_light_blue
#   bg_light_magenta
#   bg_light_cyan
#   bg_white
#   fnt_reset
# Arguments:
#   None
# Returns:
#   None
#
function color_test() {
  trace 'Printing color table.'
  command -p echo -e "Foreground:"
  command -p echo -e  "fg_default:    ${fg_default}fg_default${fnt_reset}"
  command -p echo -en "fg_black:      ${fg_black}fg_black${fnt_reset}      "
  command -p echo -e  "fg_dark_gray:     ${fg_dark_gray}fg_dark_gray${fnt_reset}"
  command -p echo -en "fg_red:        ${fg_red}fg_red${fnt_reset}        "
  command -p echo -e  "fg_light_red:     ${fg_light_red}fg_light_red${fnt_reset}"
  command -p echo -en "fg_green:      ${fg_green}fg_green${fnt_reset}      "
  command -p echo -e  "fg_light_green:   ${fg_light_green}fg_light_green${fnt_reset}"
  command -p echo -en "fg_yellow:     ${fg_yellow}fg_yellow${fnt_reset}     "
  command -p echo -e  "fg_light_yellow : ${fg_light_yellow}fg_light_yellow${fnt_reset}"
  command -p echo -en "fg_blue:       ${fg_blue}fg_blue${fnt_reset}       "
  command -p echo -e  "fg_light_blue:    ${fg_light_blue}fg_light_blue${fnt_reset}"
  command -p echo -en "fg_magenta:    ${fg_magenta}fg_magenta${fnt_reset}    "
  command -p echo -e  "fg_light_magenta: ${fg_light_magenta}fg_light_magenta${fnt_reset}"
  command -p echo -en "fg_cyan:       ${fg_cyan}fg_cyan${fnt_reset}       "
  command -p echo -e  "fg_light_cyan:    ${fg_light_cyan}fg_light_cyan${fnt_reset}"
  command -p echo -en "fg_light_gray: ${fg_light_gray}fg_light_gray${fnt_reset} "
  command -p echo -e  "fg_white:         ${fg_white}fg_white${fnt_reset}"
  command -p echo -e "Background:"
  command -p echo -e  "bg_default:    ${bg_default}bg_default${fnt_reset}"
  command -p echo -en "bg_black:      ${bg_black}bg_black${fnt_reset}      "
  command -p echo -e  "bg_dark_gray:     ${bg_dark_gray}bg_dark_gray${fnt_reset}"
  command -p echo -en "bg_red:        ${bg_red}bg_red${fnt_reset}        "
  command -p echo -e  "bg_light_red:     ${bg_light_red}bg_light_red${fnt_reset}"
  command -p echo -en "bg_green:      ${bg_green}bg_green${fnt_reset}      "
  command -p echo -e  "bg_light_green:   ${bg_light_green}bg_light_green${fnt_reset}"
  command -p echo -en "bg_yellow:     ${bg_yellow}bg_yellow${fnt_reset}     "
  command -p echo -e  "bg_light_yellow : ${bg_light_yellow}bg_light_yellow${fnt_reset}"
  command -p echo -en "bg_blue:       ${bg_blue}bg_blue${fnt_reset}       "
  command -p echo -e  "bg_light_blue:    ${bg_light_blue}bg_light_blue${fnt_reset}"
  command -p echo -en "bg_magenta:    ${bg_magenta}bg_magenta${fnt_reset}    "
  command -p echo -e  "bg_light_magenta: ${bg_light_magenta}bg_light_magenta${fnt_reset}"
  command -p echo -en "bg_cyan:       ${bg_cyan}bg_cyan${fnt_reset}       "
  command -p echo -e  "bg_light_cyan:    ${bg_light_cyan}bg_light_cyan${fnt_reset}"
  command -p echo -en "bg_light_gray: ${bg_light_gray}bg_light_gray${fnt_reset} "
  command -p echo -e  "bg_white:         ${bg_white}bg_white${fnt_reset}"
  return $EX_OK
}



###############################################################################
#                               SIGNAL TRAPPING                               #
###############################################################################
# Variables
declare -a traps=(
  ERR
  INT
)

##
# Trap a signal or release it.
# Globals:
#   None
# Arguments:
#   Signal name(case or "SIG"-prefix irrelevant)
#   Callback function(Or "-" to release the signal from the trap)
# Returns:
#   Success/Failure
#
function trap_sig() {
  local -u sig="$1"
  sig="${1/SIG/}"
  if [[ "$2" = "-" ]]; then
    trace "Removing trap of signal 'SIG$sig'."
    if ! trap "-" "$sig"; then
      warn 'Could not release signal.'
      return $EX_ERR
    fi
  else
    local -l callback="sig_$sig"
    callback="${callback/+/_}"
    callback="${callback/-/_}"
    local delegate=$(cat <<EOF
          $2
          if type $callback &> /dev/null; then
            trace "Calling callback function '$callback()'."
            $callback $cb_arg
          else
            error "Callback function '$callback()' not defined."
          fi
EOF
    )
    trace "Trapping 'SIG$sig'. Callback: $callback()."
    if ! trap "$delegate" "$sig"; then
      warn 'Could not trap signal.'
      return $EX_ERR
    fi
  fi
  return $EX_OK
}

##
# Traps all the signals specified in the traps-array.
# Globals:
#   traps
#   BASH_REMATCH
# Arguments:
#   None
# Returns:
#   Success/Failure
#
function trap_signals() {
  trace 'Trapping signals.'
  local -u sig
  for sig in "${traps[@]}"; do
    case $sig in
      EXIT)
        trap_sig EXIT 'info "Exiting script. Cleaning up."'
        ;;
      ERR)
        trap_sig ERR 'error "An Error occurred: $?\n$(check_retval $?)"'
        ;;
      DEBUG)
        trap_sig DEBUG 'info "Debugging."'
        ;;
      RETURN)
        trap_sig RETURN 'info "Returning from sourced script."'
        ;;
      HUP)
        trap_sig HUP 'fatal "Hangup. The controlling terminal closed."'
        ;;
      INT)
        trap_sig INT 'printf "\033[2D"; info "Terminal interrupt signal. User wishes to ${fnt_bold}interrupt${fnt_no_bold} the process."'
        ;;
      QUIT)
        trap_sig QUIT 'info "Terminal quit signal. User requests that the process ${fnt_bold}quits${fnt_no_bold} and performs a core dump."'
        ;;
      ILL)
        trap_sig ILL 'error "Illegal Instruction: Process attempted to execute an illegal, malformed, unknown, or privileged instruction."'
        ;;
      TRAP)
        trap_sig TRAP 'info "Trace/breakpoint trap. An exception (or ${fnt_bold}trap${fnt_no_bold}) occured."'
        ;;
      ABRT)
        trap_sig ABRT 'warn "Process abort signal. Got told to ${fnt_bold}abort${fnt_no_bold}/terminate."'
        ;;
      BUS)
        trap_sig BUS 'error "Access to an undefined portion of a memory object."'
        ;;
      BUS)
        trap_sig FPE 'error "Floating-point exception. Erroneous arithmetic operation."'
        ;;
      USR1)
        trap_sig USR1 'info "USR1 received. User-defined condition."'
        ;;
      USR2)
        trap_sig USR2 'info "USR2 received. User-defined condition."'
        ;;
      SEGV)
        trap_sig SEGV 'error "Segmentation violation. Invalid virtual memory reference(segmentation fault)."'
        ;;
      PIPE)
        trap_sig PIPE 'error "Process attempted to write to a pipe without a process connected to the other end."'
        ;;
      ALRM|VTALRM|PROF)
        trap_sig ALRM 'info "The time limit specified in a call to a preceding ${fnt_bold}alarm${fnt_no_bold} setting function (such as \"setitimer\") has elapsed."'
        ;;
      TERM)
        trap_sig TERM 'info "Process ${fnt_bold}termination${fnt_no_bold} requested."'
        ;;
      STKFLT)
        trap_sig STKFLT 'error "Stack fault. (i.e. popping when the stack is empty or pushing when it is full)."'
        ;;
      CHLD)
        trap_sig CHLD 'info "Child process terminated/interrupted/resumed."'
        ;;
      CONT)
        trap_sig CONT 'info "Continuing execution."'
        ;;
      STOP|TSTP)
        trap_sig STOP 'printf "\033[2D"; info "Stopping execution."'
        ;;
      TTIN)
        trap_sig TTIN 'trace "Attempting to read in from the ${fnt_bold}tty${fnt_no_bold} while in the background."'
        ;;
      TTOU)
        trap_sig TTOU 'trace "Attempting to read out from the ${fnt_bold}tty${fnt_no_bold} while in the background."'
        ;;
      URG)
        trap_sig URG 'info "A socket has urgent or out-of-band data available to read."'
        ;;
      XCPU)
        trap_sig XCPU 'fatal "CPU time limit exceeded."'
        ;;
      XFSZ)
        trap_sig XFSZ 'fatal "File size limit exceeded."'
        ;;
      WINCH)
        trap_sig WINCH 'info "Controlling terminal changed its size."'
        ;;
      POLL)
        trap_sig POLL 'info "An event occurred on an explicitly watched file descriptor."'
        ;;
      PWR)
        trap_sig PWR 'fatal "The system experiences a power failure."'
        ;;
      SYS)
        trap_sig SYS 'error "The process passed a bad argument to a system call."'
        ;;
      RTMIN*)
        local -i num
        if [[ $sig =~ ^RTMIN\+([1-9]([0-5]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMIN$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MIN $num.\""
        ;;
      RTMAX*)
        local -i num
        if [[ $sig =~ ^RTMAX\-([1-9]([0-4]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMAX$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MAX $num.\""
        ;;
      *)
        debug "Signal 'SIG$sig' unknown. Trying to trap anyway."
        trap_sig "$sig" 'trace "Recieved "SIG$sig" signal."'
        ;;
    esac
  done
  return $EX_OK
}



###############################################################################
#                               OPTION PARSING                                #
###############################################################################
# Variables
declare -a opts_var=()
declare -a opts_short=()
declare -a opts_long=()
declare -a opts_arg=()
declare -a opts_help=()

define_opt() {
  trace "Defining option."
  opts_var+=("$1")
  opts_short+=("$2")
  opts_long+=("$3")
  opts_arg+=("$4")
  opts_help+=("$5")
  debug "Defined option. Short: '$1'. Long: '$2'. Argument: '$3'"
}

##
# Parses the specified options from the script arguments.
# Globals:
#   None
# Arguments:
#   The script arguments ($@)
# Returns:
#   None
#
function parse_opts() {
  # Define helper functions
  function find_matching_opt() {
    trace "Matching '$opt' against the defined options."
    for index in "${!opts_short[@]}"; do
      if [[ $opt =~ ^\s*(${opts_short[$index]}|${opts_long[$index]}) ]]; then
        trace "Found a match at index '$index'."
        return $EX_OK
      fi
    done
    trace 'No match found.'
    return $EX_ERR
  }
  function expects_argument() {
    trace "Checking if '$opt' expects an argument."
    if [[ -n "${opts_arg[$index]}" ]]; then
      trace "Argument '${opts_arg[$index]}' expected."
      return $EX_OK
    fi
    trace 'No argument expected.'
    return $EX_ERR
  }
  function set_option_variable() {
    trace "Set argument for '${opts_var[$index]}'."
    if [[ ! $opt =~ ^\s*(${opts_short[$index]}|${opts_long[$index]})\s*(.*)$ ]]; then
      fatal "Could not match '$opt' with the selected option."
    fi
    local arg="${BASH_REMATCH[2]}"
    local var="${opts_var[$index]}"
    eval "$var="$arg""
    return $EX_OK
  }

  # Do it
  trace "Parsing options."
  local -a args_old=("$@")
  local -a args=("$@")
  local opt
  for opt in "${args[@]}"; do
    local -i index
    find_matching_opt
    if (( $index >= 0 )); then
      # Option found
      if expects_argument; then
        set_option_variable
      else
        niy
      fi
    else
      # Argument found
      niy
    fi
  done


  local last_opt_name
  for opt in "${args[@]}"; do
    # If the string starts with only one dash/plus, 
    if [[ $opt =~ ^([^a-zA-Z0-9_\-][^-]).+$ ]]; then
      debug "Need to split the arguments($opt)."
      local cur_opt="${BASH_REMATCH[1]}"
      opt="-${opt:2:${#opt}}"
      if check_if_arg "$cur_opt"; then
        # Assign rest of string as argument.
        if [[ -z "$opt" ]]; then
          # Argument isn't on this string.
          local opt_var
          get_opt_var $opt
          last_opt_name="$opt_var"
          continue
        else
          niy
        fi
      fi
      while true; do
        return
      done
    fi
  done
  return $EX_OK


  local IFS=","
  debug "Arguments supplied: '${args[*]}'" 
  subtitute_long
  debug "Arguments after shortening: '${args[*]}'" 
  local opt
  while command -p getopts "$opts" opt ${args[@]}; do
    echo "$opt" $OPTIND $OPTARG
    debug "Checking option '$opt'"
    local optname="opt_$opt"
    eval "$optname=1"
    if [[ $opts_new =~ $opt: ]]; then # Argument provided
      eval "$opt="${OPTARG}""
      debug "Found option '$optname=$opt'."
    else
      debug "Found option '$opt'."
    fi
  done
  return $EX_OK
}


function assign_opt_val() {
  local opt="$1"
  local val="$2"
  local -i index
  if [[ ${#opt} = 2 ]]; then
    for index in "${!opts_short[@]}"; do
      if [[ "${opts_short[$index]}" = "$short" ]]; then
        
        break
      fi
    done
  else
    niy
  fi
}

function get_opt_var() {
  opt_var="opt_${${${1/^-/}/^-/}/-/_}"
}

function check_if_arg() {
  trace "Check if short option expects an argument or not."
  local short="$1"
  for index in "${!opts_short[@]}"; do
    if [[ "${opts_short[$index]}" = "$short" ]]; then
      if [[ -n "${opts_arg[$index]}" ]]; then
        trace "It does expect an argument."
        return $EX_OK;
      fi
      break
    fi
  done
  trace "It does not expect an argument."
  return $EX_ERR
}

function parse_single_option() {
  local flag="$1"
  local argument="$2"
  trace "Parsing single option: $1 $2"
  local -i index
  if [[ ${#flag} = 1 ]]; then
    for index in "${!opts_short[@]}"; do
      if [[ "${opts_short[$index]}" = "$flag" ]]; then
        return
      fi
    done
  else
    return
  fi
}
function assign_option() {
  local -i index="$1"
  local short="${opts_short[$index]}"
  local long="${opts_long[$index]}"
  local argument="$2"
  if [[ -n "$short" ]]; then
    local name_short="opt_$short"
  fi
}

function subtitute_long() {
  trace 'Substituting long options to short ones.'
  local -i index
  local key
  for key in "${!option_map[@]}"; do
    for index in "${!args[@]}"; do
    local arg="${args[$index]}"
      if [[ $arg =~ ^--$key(\s.*$|$) ]]; then
        local shortened="-${option_map[$key]}${BASH_REMATCH[1]}"
        args[$index]="$shortened"
        debug "Changed option '$arg' to '$shortened'."
      fi
    done
  done
  trace 'Done with the substitution.'
  return $EX_OK
}

function prefetch_options() {
  if [[ $opts =~ $DEFAULT_OPTS.* ]]; then
    # Parsing options early
    if test_option "$@" 'h'; then 
      print_help
      exit $EX_OK
    fi
    if test_option "$@" 'q'; then
      loglevel=$LL_QUIET
    elif test_option "$@" 'v'; then
      loglevel=$LL_TRACE
      debug "Set log level to $loglevel."
    elif test_option "$@" 'l\ *([0-9]*)'; then
      loglevel=${BASH_REMATCH[1]}
    fi
    if [[ $loglevel -ne $LL_QUIET ]]; then
      debug "Set log level to $loglevel"
    fi
    if [[ -z "$trapping" ]]; then
      trap_signals
    fi
  fi
  return $EX_OK
}

##
# Prints the usage and help text.
# Globals:
#   opts
#   DEFAULT_OPTS
# Arguments:
#   The script arguments ($@)
# Returns:
#   None
#
function print_help() {
  echo -n 'Usage: '
  for syn in "${syntax[@]}"; do
    echo "$(basename $0) $syn"
    echo -n '       '
  done
  echo -en '\033[7D'
  echo "$usage"
  echo
  for option in "${optArray[@]}"; do
    get_opt "$option"
    if [[ -n "$short" ]]; then
      echo -n "  -$short"
      if [[ -n "$long" ]]; then
        echo -n ','
      else
        echo -n ' '
      fi
    else
      echo -en '     '
    fi
    if [[ -n "$long" ]]; then
      line=" --$long"
      if [[ -n "$argument" ]]; then
        line="$line $argument"
      fi
      let "len = $maxlen - ${#line} + 1"
      echo -en "$line "
      printf ' %.0s' {1..$len}
    else
      printf ' %.0s' {1..$maxlen}
    fi
    echo -e "$descr"
  done
  return $EX_OK
}

function test_option() {
  [[ \ $1 =~  \ -[a-zA-Z0-9]*$2 ]] && return $EX_OK;
  return $EX_ERR;
}



###############################################################################
#                                     EOF                                     #
###############################################################################

# Setup:
loglevel=$LL_TRACE

define_opt "_log" "-l" "" "<n>" "Log level <n>."
define_opt "_help" "-h" "--help" "" "Display this help text."
define_opt "_ver" "-v" "" "" "Display the version."
define_opt "_file" "" "--file" "<file>" "Load settings from <file>."

syntax=(
  '[OPTION]...'
  '[OPTION]... [FILE]'
)
usage='Remove (unlink) the FILE(s).'

parse_opts "$@"
echo "_log = $_log"
exit

# Traps:
traps=(
  ERR
  INT
)
sig_err() { exit; }
sig_int() { exit; }
trap_signals

color_test
exit
# Code
sig_debug() {
    local -i row="$((${BASH_LINENO[0]} - 3))"
    local text=$(sed "${row}q;d" "$(basename $0)")
    debug "$row: $text"
    read;
}
trap_sig DEBUG ''
echo "$LINENO"
echo "$LINENO"
echo "a = $a"
if type setterm &>/dev/null; then
  read
  setterm --term linux --back green --fore black --clear all
fi
while true; do
  ls &> /dev/null
done