#!/bin/bash -
#==============================================================================
#title          :bashme.sh
#description    :A bash template which manages vital mechanisms for bash
#                scripting.
#author         :Raphael Emberger
#date           :20180612
#VERSION        :0.1    
#EXPLANATION          :./bashme.sh
#notes          :
#bash_version   :4.4.12(1)-release
#==============================================================================



###############################################################################
#                                  LOGGING                                    #
###############################################################################
# Constants
declare -ri LL_TRACE=0
declare -ri LL_DEBUG=1
declare -ri LL_INFO=2
declare -ri LL_WARN=3
declare -ri LL_ERROR=4
declare -ri LL_FATAL=5
declare -ri LL_QUIET=6

# Variables
declare -i loglevel=$LL_INFO
declare logfile="./$(basename "$0").log"
declare log2file=''
declare log2std=1

##
# Logs a message according to its log level.
# Globals:
#   BASH_LINENO
#   FUNCNAME
#   BASH_SOURCE
#   LL_ERROR
#   RESET
#   log2std
#   log2file
#   logfile
# Arguments:
#   Color
#   Log level
#   Literal log level
#   Log message
# Returns:
#   None
#
function log() {
  local lineno="${BASH_LINENO[$((${#BASH_LINENO} - 1))]}"
  local location=" ${FUNCNAME[2]}(): "
  local logmsg="$(date '+%Y-%M-%d %H:%m:%S') $3($lineno)$location$4"
  if [[ -n "$log2std" ]]; then
    if (( $2 >= $LL_ERROR )); then
      echo -e "$1$logmsg$RESET" >&2
    else
      echo -e "$1$logmsg$RESET"
    fi
  fi
  [[ -n "$log2file" ]] && echo "$logmsg" >> $logfile
  return $EX_OK
}

##
# Logs a message on the trace level.
# Globals:
#   LL_TRACE
#   FG_LGRAY
#   DIM
#   loglevel
# Arguments:
#   Log message
# Returns:
#   None
#
function trace() {
  [[ $loglevel -gt $LL_TRACE ]] && return $EX_OK
  log "$FG_LGRAY$DIM" $LL_TRACE '[TRACE]' "$1"
  return $EX_OK
}

##
# Logs a message on the debug level.
# Globals:
#   LL_DEBUG
#   FG_LGRAY
#   loglevel
# Arguments:
#   Log message
# Returns:
#   None
#
function debug() {
  [[ $loglevel -gt $LL_DEBUG ]] && return $EX_OK
  log "$FG_LGRAY" $LL_DEBUG '[DEBUG]' "$1"
  return $EX_OK
}

##
# Logs a message on the info level.
# Globals:
#   LL_INFO
#   FG_WHITE
#   loglevel
# Arguments:
#   Log message
# Returns:
#   None
#
function info() {
  [[ $loglevel -gt $LL_INFO ]] && return $EX_OK
  log "$FG_WHITE" $LL_INFO '[INFO] ' "$1"
  return $EX_OK
}

##
# Logs a message on the warn level.
# Globals:
#   LL_WARN
#   FG_YELLOW
#   loglevel
# Arguments:
#   Log message
# Returns:
#   None
#
function warn() {
  [[ $loglevel -gt $LL_WARN ]] && return $EX_OK
  log "$FG_YELLOW" $LL_WARN '[WARN] ' "$1"
  return $EX_OK
}

##
# Logs a message on the error level.
# Globals:
#   LL_ERROR
#   FG_RED
#   loglevel
# Arguments:
#   Log message
# Returns:
#   None
#
function error() {
  [[ $loglevel -gt $LL_ERROR ]] && return $EX_OK
  log "$FG_RED" $LL_ERROR '[ERROR]' "$1"
  return $EX_OK
}

##
# Logs a message on the fatal level.
# Globals:
#   LL_FATAL
#   FG_RED
#   loglevel
# Arguments:
#   Log message
# Returns:
#   None
#
function fatal() {
  [[ $loglevel -gt $LL_FATAL ]] && return $EX_OK
  log "$FG_LRED$BOLD" $LL_FATAL '[FATAL]' "$1"
  return $EX_OK
}

##
# A makeshift function to cover logging the access to not yet implemented.
# functionality.
# Globals:
#   LL_WARN
#   FG_LYELLOW
#   BOLD
#   loglevel
# Arguments:
#   None
# Returns:
#   None
#
function NYI() {
  function log_nyi() {
    [[ $loglevel -gt $LL_INFO ]] && return $EX_OK
    log "$FG_LYELLOW$BOLD" $LL_WARN '[TODO]' "$1"
    return $EX_OK
  }
  log_nyi "Not yet implemented!"
  return $EX_OK
}

##
# Marks a position in the code as a TODO.
# Globals:
#   LL_INFO
#   FG_GREEN
#   BOLD
#   loglevel
# Arguments:
#   The description of the work to be done.
# Returns:
#   None
#
function TODO() {
  function log_todo() {
    [[ $loglevel -gt $LL_INFO ]] && return $EX_OK
    log "$FG_GREEN$BOLD" $LL_INFO '[TODO]' "$1"
    return $EX_OK
  }
  log_todo "$1"
  return $EX_OK
}



###############################################################################
#                                RETURN VALUE                                 #
###############################################################################
# Constants
declare -ri EX_OK=0
declare -ri EX_ERR=1
declare -ri EX_MISSUSE=2
declare -ri EX_CANNOTEXEC=126
declare -ri EX_CMDNOTFOUND=127
declare -ri EX_INVALARG=128
declare -ri EX_FATAL_BASE=128
declare -ri EX_INT=130
declare -ri EX_OUTOFRANGE=255

##
# Checks the last return value and writes logs.
# Globals:
#   None
# Arguments:
#   Last return value ($?)
# Returns:
#   Last return value ($?)
#
function check_retval() {
  trace "Checking return value: $1"
  local retval="$1"
  local excode="return value $retval: "
  if [[ $retval -gt 64 ]] && [[ $retval -lt 114 ]]; then
    debug "${excode}Custom C/C++ return code according to /usr/include/sysexits.h detected."
  fi
  if [[ $retval -gt 128 ]] && [[ $retval -lt 166 ]]; then
    debug "${excode}Custom fatal return value detected."
  fi
  case $retval in
    $EX_OK)
      debug "${excode}Code exited normally."
      ;;
    $EX_ERR)
      debug "${excode}Catchall for general errors. Miscellaneous errors, such as 'divide by zero' and other impermissible operations."
      ;;
    $EX_MISSUSE)
      debug "${excode}Misuse of shell builtins. Missing keyword or command or permission problem."
      ;;
    $EX_CANNOTEXEC)
      debug "${excode}Command invoked cannot execute. Permission problem or command is not an executable."
      ;;
    $EX_CMDNOTFOUND)
      debug "${excode}Command not found. Possible problem with \$PATH or a typo."
      ;;
    $EX_INVALARG)
      debug "${excode}Invalid argument to exit. exit takes only integer args in the range 0 - 255."
      ;;
    $EX_INT)
      debug "${excode}Command terminated by Control-C."
      ;;
    $EX_OUTOFRANGE)
      debug "${excode}Exit status out of range. exit takes only integer args in the range 0 - 255."
      ;;
    ?)
      warn "Could not categorize return value $retval appropriately."
  esac
  return $retval
}




###############################################################################
#                            COLORS AND FORMATTING                            #
###############################################################################
# Constants
readonly FG_BLACK="$(tput setaf 0)"
readonly FG_RED="$(tput setaf 1)"
readonly FG_GREEN="$(tput setaf 2)"
readonly FG_YELLOW="$(tput setaf 3)"
readonly FG_BLUE="$(tput setaf 4)"
readonly FG_MAGENTA="$(tput setaf 5)"
readonly FG_CYAN="$(tput setaf 6)"
readonly FG_LGRAY="$(tput setaf 7)"
readonly FG_GRAY="$(tput setaf 8)"
readonly FG_LRED="$(tput setaf 9)"
readonly FG_LGREEN="$(tput setaf 10)"
readonly FG_LYELLOW="$(tput setaf 11)"
readonly FG_LBLUE="$(tput setaf 12)"
readonly FG_LMAGENTA="$(tput setaf 13)"
readonly FG_LCYAN="$(tput setaf 14)"
readonly FG_WHITE="$(tput setaf 15)"

readonly BG_BLACK="$(tput setab 0)"
readonly BG_RED="$(tput setab 1)"
readonly BG_GREEN="$(tput setab 2)"
readonly BG_YELLOW="$(tput setab 3)"
readonly BG_BLUE="$(tput setab 4)"
readonly BG_MAGENTA="$(tput setab 5)"
readonly BG_CYAN="$(tput setab 6)"
readonly BG_LGRAY="$(tput setab 7)"
readonly BG_GRAY="$(tput setab 8)"
readonly BG_LRED="$(tput setab 9)"
readonly BG_LGREEN="$(tput setab 10)"
readonly BG_LYELLOW="$(tput setab 11)"
readonly BG_LBLUE="$(tput setab 12)"
readonly BG_LMAGENTA="$(tput setab 13)"
readonly BG_LCYAN="$(tput setab 14)"
readonly BG_WHITE="$(tput setab 15)"

readonly BOLD="$(tput bold)"
readonly DIM="$(tput dim)"
readonly ITALIC="$(tput sitm)"
readonly STANDOUT="$(tput smso)"
readonly STANDOUT_STOP="$(tput rmso)"
readonly UNDERLINE="$(tput smul)"
readonly UNDERLINE_STOP="$(tput rmul)"
readonly BLINK="$(tput blink)"
readonly REVERSE="$(tput rev)"
readonly INVISIBLE="$(tput invis)"
readonly STRIKEOUT="$(tput os)"

readonly RESET="$(tput sgr0)"

##
# Prints a table of all the available formats.
# Globals:
#   BOLD
#   DIM
#   ITALIC
#   UNDERLINE
#   BLINK
#   REVERSE
#   INVISIBLE
#   STRIKEOUT
#   UNDERLINE_STOP
#   RESET
# Arguments:
#   None
# Returns:
#   None
#
function formatting_test() {
  trace 'Printing formatting table.'
  echo -e "Formattings:"
  echo -e "BOLD:      ${BOLD}BOLD${RESET}."
  echo -e "DIM:       ${DIM}DIM${RESET}."
  echo -e "ITALIC:    ${ITALIC}ITALIC${RESET}."
  echo -e "UNDERLINE: ${UNDERLINE}UNDERLINE${UNDERLINE_STOP}."
  echo -e "STANDOUT:  ${STANDOUT}STANDOUT${STANDOUT_STOP}."
  echo -e "BLINK:     ${BLINK}BLINK${RESET}."
  echo -e "REVERSE:   ${REVERSE}REVERSE${RESET}."
  echo -e "INVISIBLE: ${INVISIBLE}INVISIBLE${RESET}."
  echo -e "STRIKEOUT: ${STRIKEOUT}STRIKEOUT${RESET}."
  return $EX_OK
}

##
# Prints a table of all the available colors.
# Globals:
#   FG_BLACK
#   FG_RED
#   FG_GREEN
#   FG_YELLOW
#   FG_BLUE
#   FG_MAGENTA
#   FG_CYAN
#   FG_LGRAY
#   FG_GRAY
#   FG_LRED
#   FG_LGREEN
#   FG_LYELLOW
#   FG_LBLUE
#   FG_LMAGENTA
#   FG_LCYAN
#   FG_WHITE
#   BG_BLACK
#   BG_RED
#   BG_GREEN
#   BG_YELLOW
#   BG_BLUE
#   BG_MAGENTA
#   BG_CYAN
#   BG_LGRAY
#   BG_GRAY
#   BG_LRED
#   BG_LGREEN
#   BG_LYELLOW
#   BG_LBLUE
#   BG_LMAGENTA
#   BG_LCYAN
#   BG_WHITE
#   RESET
# Arguments:
#   None
# Returns:
#   None
#
function color_test() {
  trace 'Printing color table.'
  echo -e "Foreground:"
  echo -en "FG_BLACK:      ${FG_BLACK}FG_BLACK${RESET}      "
  echo -e  "FG_GRAY:     ${FG_GRAY}FG_GRAY${RESET}"
  echo -en "FG_RED:        ${FG_RED}FG_RED${RESET}        "
  echo -e  "FG_LRED:     ${FG_LRED}FG_LRED${RESET}"
  echo -en "FG_GREEN:      ${FG_GREEN}FG_GREEN${RESET}      "
  echo -e  "FG_LGREEN:   ${FG_LGREEN}FG_LGREEN${RESET}"
  echo -en "FG_YELLOW:     ${FG_YELLOW}FG_YELLOW${RESET}     "
  echo -e  "FG_LYELLOW : ${FG_LYELLOW}FG_LYELLOW${RESET}"
  echo -en "FG_BLUE:       ${FG_BLUE}FG_BLUE${RESET}       "
  echo -e  "FG_LBLUE:    ${FG_LBLUE}FG_LBLUE${RESET}"
  echo -en "FG_MAGENTA:    ${FG_MAGENTA}FG_MAGENTA${RESET}    "
  echo -e  "FG_LMAGENTA: ${FG_LMAGENTA}FG_LMAGENTA${RESET}"
  echo -en "FG_CYAN:       ${FG_CYAN}FG_CYAN${RESET}       "
  echo -e  "FG_LCYAN:    ${FG_LCYAN}FG_LCYAN${RESET}"
  echo -en "FG_LGRAY: ${FG_LGRAY}FG_LGRAY${RESET} "
  echo -e  "FG_WHITE:         ${FG_WHITE}FG_WHITE${RESET}"
  echo -e "Background:"
  echo -en "BG_BLACK:      ${BG_BLACK}BG_BLACK${RESET}      "
  echo -e  "BG_GRAY:     ${BG_GRAY}BG_GRAY${RESET}"
  echo -en "BG_RED:        ${BG_RED}BG_RED${RESET}        "
  echo -e  "BG_LRED:     ${BG_LRED}BG_LRED${RESET}"
  echo -en "BG_GREEN:      ${BG_GREEN}BG_GREEN${RESET}      "
  echo -e  "BG_LGREEN:   ${BG_LGREEN}BG_LGREEN${RESET}"
  echo -en "BG_YELLOW:     ${BG_YELLOW}BG_YELLOW${RESET}     "
  echo -e  "BG_LYELLOW : ${BG_LYELLOW}BG_LYELLOW${RESET}"
  echo -en "BG_BLUE:       ${BG_BLUE}BG_BLUE${RESET}       "
  echo -e  "BG_LBLUE:    ${BG_LBLUE}BG_LBLUE${RESET}"
  echo -en "BG_MAGENTA:    ${BG_MAGENTA}BG_MAGENTA${RESET}    "
  echo -e  "BG_LMAGENTA: ${BG_LMAGENTA}BG_LMAGENTA${RESET}"
  echo -en "BG_CYAN:       ${BG_CYAN}BG_CYAN${RESET}       "
  echo -e  "BG_LCYAN:    ${BG_LCYAN}BG_LCYAN${RESET}"
  echo -en "BG_LGRAY: ${BG_LGRAY}BG_LGRAY${RESET} "
  echo -e  "BG_WHITE:         ${BG_WHITE}BG_WHITE${RESET}"
  return $EX_OK
}



###############################################################################
#                               SIGNAL TRAPPING                               #
###############################################################################
# Variables
declare -a traps=(
  ERR
  INT
)
sig_err() { exit; }
sig_int() { exit; }
sig_debug() { return; }


##
# Trap a signal or release it.
# Globals:
#   None
# Arguments:
#   Signal PROGRAM_NAME(case or "SIG"-prefix irrelevant)
#   Callback function(Or "-" to release the signal from the trap)
# Returns:
#   Success/Failure
#
function trap_sig() {
  local -u sig="$1"
  sig="${1/SIG/}"
  if [[ "$2" = "-" ]]; then
    trace "Removing trap of signal 'SIG$sig'."
    if ! trap "-" "$sig"; then
      warn 'Could not release signal.'
      return $EX_ERR
    fi
  else
    local -l callback="sig_$sig"
    callback="${callback/+/_}"
    callback="${callback/-/_}"
    local delegate=$(cat <<EOF
          $2
          if type $callback &> /dev/null; then
            trace "Calling callback function '$callback()'."
            $callback $cb_arg
          else
            error "Callback function '$callback()' not defined."
          fi
EOF
    )
    trace "Trapping 'SIG$sig'. Callback: $callback()."
    if ! trap "$delegate" "$sig"; then
      warn 'Could not trap signal.'
      return $EX_ERR
    fi
  fi
  return $EX_OK
}

##
# Traps all the signals specified in the traps-array.
# Globals:
#   traps
#   BASH_REMATCH
# Arguments:
#   None
# Returns:
#   Success/Failure
#
function trap_signals() {
  trace 'Trapping signals.'
  local -u sig
  for sig in "${traps[@]}"; do
    case $sig in
      EXIT)
        trap_sig EXIT 'info "Exiting script. Cleaning up."'
        ;;
      ERR)
        trap_sig ERR 'errcode=$?; error "An Error occurred: $errcode"; check_retval $errcode'
        ;;
      DEBUG)
        trap_sig DEBUG 'info "Debugging."'
        ;;
      RETURN)
        trap_sig RETURN 'info "Returning from sourced script."'
        ;;
      HUP)
        trap_sig HUP 'fatal "Hangup. The controlling terminal closed."'
        ;;
      INT)
        trap_sig INT 'printf "\033[2D"; info "Terminal interrupt signal. User wishes to interrupt the process."'
        ;;
      QUIT)
        trap_sig QUIT 'info "Terminal quit signal. User requests that the process quits and performs a core dump."'
        ;;
      ILL)
        trap_sig ILL 'error "Illegal Instruction: Process attempted to execute an illegal, malformed, unknown, or privileged instruction."'
        ;;
      TRAP)
        trap_sig TRAP 'info "Trace/breakpoint trap. An exception (or trap) occured."'
        ;;
      ABRT)
        trap_sig ABRT 'warn "Process abort signal. Got told to abort/terminate."'
        ;;
      BUS)
        trap_sig BUS 'error "Access to an undefined portion of a memory object."'
        ;;
      BUS)
        trap_sig FPE 'error "Floating-point exception. Erroneous arithmetic operation."'
        ;;
      USR1)
        trap_sig USR1 'info "USR1 received. User-defined condition."'
        ;;
      USR2)
        trap_sig USR2 'info "USR2 received. User-defined condition."'
        ;;
      SEGV)
        trap_sig SEGV 'error "Segmentation violation. Invalid virtual memory reference(segmentation fault)."'
        ;;
      PIPE)
        trap_sig PIPE 'error "Process attempted to write to a pipe without a process connected to the other end."'
        ;;
      ALRM|VTALRM|PROF)
        trap_sig ALRM 'info "The time limit specified in a call to a preceding alarm setting function (such as \"setitimer\") has elapsed."'
        ;;
      TERM)
        trap_sig TERM 'info "Process termination requested."'
        ;;
      STKFLT)
        trap_sig STKFLT 'error "Stack fault. (i.e. popping when the stack is empty or pushing when it is full)."'
        ;;
      CHLD)
        trap_sig CHLD 'info "Child process terminated/interrupted/resumed."'
        ;;
      CONT)
        trap_sig CONT 'info "Continuing execution."'
        ;;
      STOP|TSTP)
        trap_sig STOP 'printf "\033[2D"; info "Stopping execution."'
        ;;
      TTIN)
        trap_sig TTIN 'trace "Attempting to read in from the tty while in the background."'
        ;;
      TTOU)
        trap_sig TTOU 'trace "Attempting to read out from the tty while in the background."'
        ;;
      URG)
        trap_sig URG 'info "A socket has urgent or out-of-band data available to read."'
        ;;
      XCPU)
        trap_sig XCPU 'fatal "CPU time limit exceeded."'
        ;;
      XFSZ)
        trap_sig XFSZ 'fatal "File size limit exceeded."'
        ;;
      WINCH)
        trap_sig WINCH 'info "Controlling terminal changed its size."'
        ;;
      POLL)
        trap_sig POLL 'info "An event occurred on an explicitly watched file descriptor."'
        ;;
      PWR)
        trap_sig PWR 'fatal "The system experiences a power failure."'
        ;;
      SYS)
        trap_sig SYS 'error "The process passed a bad argument to a system call."'
        ;;
      RTMIN*)
        local -i num
        if [[ $sig =~ ^RTMIN\+([1-9]([0-5]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMIN$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MIN $num.\""
        ;;
      RTMAX*)
        local -i num
        if [[ $sig =~ ^RTMAX\-([1-9]([0-4]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMAX$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MAX $num.\""
        ;;
      *)
        debug "Signal 'SIG$sig' unknown. Trying to trap anyway."
        trap_sig "$sig" 'trace "Recieved "SIG$sig" signal."'
        ;;
    esac
  done
  return $EX_OK
}



###############################################################################
#                               OPTION PARSING                                #
###############################################################################
# Variables
declare -a opts_var=()
declare -a opts_short=()
declare -a opts_long=()
declare -a opts_arg=()
declare -a opts_help=()
declare -i max_len_long=0
declare -i max_len_arg=0
declare -a args=()
declare PROGRAM_NAME
declare VERSION
declare -i YEAR
declare FULL_NAME
declare -a USAGE
declare EXPLANATION
declare DESCRIPTION

##
# Defines an option to be parsed for and to put into the help page.
# Globals:
#   opts_var
#   opts_short
#   opts_long
#   opts_arg
#   opts_help
#   max_len_long
#   max_len_arg
# Arguments:
#   The variable to set
#   The short command(optional)
#   The long command(optional)
#   The argument of the option(optional)
#   The description of the option
# Returns:
#   None
#
define_opt() {
  debug "Defining option '$1'. Short: '$2'. Long: '$3'. Argument: '$4'."
  opts_var+=("$1")
  opts_short+=("$2")
  opts_long+=("$3")
  opts_arg+=("$4")
  opts_help+=("$5")
  max_len_long="$((${#3} > max_len_long ? ${#3} : max_len_long))"
  max_len_arg="$((${#4} > max_len_arg ? ${#4} : max_len_arg))"
}

##
# Parses the specified options from the script arguments.
# Globals:
#   BASH_REMATCH
#   opts_var
#   opts_short
#   opts_long
#   opts_arg
#   opts_help
#   args
# Arguments:
#   The script arguments ($@)
# Returns:
#   None
#
function parse_args() {
  # Define helper functions
  function find_matching_opt() {
    trace "Matching '$opt_str' against the defined options."
    for index in "${!opts_short[@]}"; do
      local short="${opts_short[$index]}"
      local long="${opts_long[$index]}"
      # Fix matching of no such option defined:
      [[ -z "$long" ]] && long="#"
      [[ -z "$short" ]] && short="#"
      if [[ $opt_str =~ ^\s*($short|$long)(.*)$ ]]; then
        opt="${BASH_REMATCH[1]}"
        opt_str="${BASH_REMATCH[2]}"
        trace "Found '$opt' at index $index. Remaining string: '$opt_str'"
        return $EX_OK
      fi
    done
    trace 'No match found.'
    return $EX_ERR
  }
  function expects_argument() {
    trace "Checking if an argument is expected."
    if [[ -n "${opts_arg[$index]}" ]]; then
      trace "Argument '${opts_arg[$index]}' expected."
      return $EX_OK
    fi
    trace 'No argument expected.'
    return $EX_ERR
  }
  function set_option_variable() {
    trace "Set argument for '${opts_var[$index]}'."
    local val="$1"
    if [[ -z "$val" ]]; then
      if [[ ! $opt =~ ^\s*(${opts_short[$index]}|${opts_long[$index]})\s*(.*)$ ]]; then
        fatal "Could not match '$opt' with the selected option."
      fi
      val="${BASH_REMATCH[2]}"
    fi
    local var="${opts_var[$index]}"
    debug "Set '$var' to '$val'"
    eval "$var=\"$val\""
    return $EX_OK
  }
  function arg_left_in_opt_str() {
    trace 'Checking if the required argument is in the remaining string.'
    if [[ -z "$opt_str" ]]; then
      trace 'No remaining argument in string.'
      return $EX_ERR
    fi
    trace "Found '$opt_str'."
    return $EX_OK
  }
  function find_index() {
    trace "Finding index to option '$opt'."
    for index in "${!opts_short[@]}"; do
      local short="${opts_short[$index]}"
      local long="${opts_long[$index]}"
      if [[ $opt =~ ^\s*($short|$long)$ ]]; then
        trace "Found option at index $index."
        return $EX_OK
      fi
    done
    warn 'Did not find index.'
    return $EX_ERR
  }

  # Do it
  trace "Parsing options."
  local -a args_old=("$@")
  local opt_str
  local last_opt
  for opt_str in "$@"; do
    trace "Checking string '$opt_str'."
    if [[ -n "$last_opt" ]]; then
      trace "Deduced to be argument for '$last_opt'."
      opt="$last_opt"
      last_opt=""
      find_index
      set_option_variable "$opt_str"
      continue
    fi
    local -i index
    local opt=""
    local ignore=""
    # Does the string start with an option?
    while find_matching_opt; do
      if expects_argument; then
        if arg_left_in_opt_str; then
          set_option_variable "$opt_str"
          ignore=true
          break
        else
          set_option_variable true
          last_opt="$opt"
          break
        fi
      else
        # Not an argument but might be another option
        set_option_variable true
        opt_str="-$opt_str"
        ignore=true
      fi
    done
    # No more options in the current opt_str
    if [[ -z "$ignore" ]] && [[ -n "$opt_str" ]]; then
      debug "Adding '$opt_str' to 'args'."
      args+=("$opt_str")
    fi
  done
  trace "Done parsing options."
  return $EX_OK
}

##
# Prints the VERSION of the script.
# Globals:
#   PROGRAM_NAME
#   EXPLANATION
#   USAGE
#   VERSION
#   DESCRIPTION
#   opts_var
#   opts_short
#   opts_long
#   opts_arg
#   opts_help
#   max_len_long
#   max_len_arg
# Arguments:
#   None
# Returns:
#   None
#
function print_usage() {
  trace "Printing EXPLANATION."
  function pad_right() {
    local -i len=$1
    local str="$2"
    local str="$2"
    printf "%*s" "$((len - ${#str}))" "$pad"
    printf '%s' "$str"
  }
  function pad_left() {
    local -i len=$1
    local str="$2"
    printf '%s' "$str"
    printf "%*.${len}s" "$((len - ${#str}))" "$pad"
  }
  echo "$PROGRAM_NAME -- $VERSION"
  local prefix='Usage:'
  local syn
  for syn in "${USAGE[@]}"; do
    pad_left 7 "$prefix"
    echo "$(basename $0) $syn"
    prefix=''
  done
  echo "$EXPLANATION"
  echo
  local -i index
  for index in "${!opts_help[@]}"; do
    local short="${opts_short[$index]}"
    local long="${opts_long[$index]}"
    local argument="${opts_arg[$index]}"
    local helptext="${opts_help[$index]}"
    if [[ -n "$short" ]]; then
      if [[ -n "$long" ]]; then
        pad_right 6 "$short, "
      else
        pad_right 6 "$short  "
      fi
    else
      pad_right 6
    fi
    pad_left "$((max_len_long + 1))" "$long"
    pad_left "$((max_len_arg + 2 + ${#ITALIC} + ${#RESET}))" "${ITALIC}$argument${RESET}"
    printf '%s' "$helptext"
    echo
  done
  echo
  echo "$DESCRIPTION"
  return $EX_OK
}

##
# Prints the VERSION of the script.
# Globals:
#   PROGRAM_NAME
#   VERSION
# Arguments:
#   None
# Returns:
#   None
#
function print_version() {
  echo "$PROGRAM_NAME version $VERSION"
  echo "$LICENCE"
}


###############################################################################
#                                 DATA TYPES                                  #
###############################################################################

##
# Declares a stack on the global scope.
# Globals:
#   ${1}    - The stack
#   ${1}_i  - The index(=size)
# Arguments:
#   The stack variable
# Returns:
#   None
#
function declare_stack() {
  local _stk="$1"
  local _stk_i="${_stk}_i"
  trace "Declaring variable '$_stk' as stack with stack pointer '$_stk_i'."
  declare -ag $_stk
  declare -ig $_stk_i
  eval "$_stk_i=0"
}

##
# Pushes a value to the stack.
# Globals:
#   ${1}    - The stack
#   ${1}_i  - The index(=size)
# Arguments:
#   The stack variable
#   The value to push
# Returns:
#   None
#
function push() {
  local _stk="$1"
  local _stk_i="${_stk}_i"
  trace "Pushing variable '$2' to stack '$_stk'."
  eval "$_stk[\$$_stk_i]=\"$2\""
  let "$_stk_i = $_stk_i + 1"
}

##
# Pops a value from the stack.
# Globals:
#   ${1}    - The stack
#   ${1}_i  - The index(=size)
# Arguments:
#   The stack variable
#   The variable to assign the popped value to
# Returns:
#   $EX_ERR if the stack is empty.
#
function pop() {
  local _stk="$1"
  local _stk_i="${_stk}_i"
  local _val="$2"
  if eval "(( $_stk_i < 1 ))"; then
    debug "Stack '$_stk' is empty."
    return $EX_ERR
  fi
  trace "Popping a variable from stack '$_stk'."
  let "$_stk_i = $_stk_i - 1"
  eval "$_val=\"\${$_stk[\$$_stk_i]}\""
  eval "unset $_stk[\$$_stk_i]"
}

##
# Peeks a value from the stack.
# Globals:
#   ${1}    - The stack
#   ${1}_i  - The index(=size)
# Arguments:
#   The stack variable
#   The variable to assign the peeked value to
# Returns:
#   $EX_ERR if the stack is empty.
#
function peek() {
  local _stk="$1"
  local _stk_i="${_stk}_i"
  local _val="$2"
  if eval "(( $_stk_i < 1 ))"; then
    debug "Stack '$_stk' is empty."
    return $EX_ERR
  fi
  trace "Peeking variable from stack '$_stk'."
  eval "$_val=\"\${$_stk[(( \$$_stk_i - 1 ))]}\""
}


##
# Declares a queue on the global scope.
# Globals:
#   ${1}    - The queue
#   ${1}_i  - The index(=size)
# Arguments:
#   The queue variable
# Returns:
#   None
#
function declare_queue() {
  local _que="$1"
  local _que_i="${_que}_i"
  trace "Declaring variable '$_que' as queue with queue pointer '$_que_i'."
  declare -ag $_que
  declare -ig $_que_i
  eval "$_que_i=0"
}

##
# Offers a value to the queue.
# Globals:
#   ${1}    - The queue
#   ${1}_i  - The index(=size)
# Arguments:
#   The queue variable
#   The value to offer
# Returns:
#   None
#
function offer() {
  local _que="$1"
  local _que_i="${_que}_i"
  trace "offering variable '$2' to queue '$_que'."
  eval "$_que[\$$_que_i]=\"$2\""
  let "$_que_i = $_que_i + 1"
}

##
# Polls a value from the queue.
# Globals:
#   ${1}    - The queue
#   ${1}_i  - The index(=size)
# Arguments:
#   The queue variable
#   The variable to assign the polled value to
# Returns:
#   $EX_ERR if the queue is empty.
#
function poll() {
  local _que="$1"
  local _que_i="${_que}_i"
  local _val="$2"
  if eval "(( $_que_i < 1 ))"; then
    debug "Queue '$_que' is empty."
    return $EX_ERR
  fi
  trace "Popping a variable from queue '$_que'."
  eval "$_val=\"\${$_que[0]}\""
  let "$_que_i = $_que_i - 1"
  local index
  for ((index=0;index<$_que_i;index++)); do
    eval "$_que[$index]=\"\${$_que[(( $index + 1 ))]}\""
  done
  eval "unset $_que[\$$_que_i]"
}

##
# Peeks a value from the queue.
# Globals:
#   ${1}    - The queue
# Arguments:
#   The queue variable
#   The variable to assign the polled value to
# Returns:
#   $EX_ERR if the queue is empty.
#
function peeq() {
  local _que="$1"
  local _que_i="${_que}_i"
  local _val="$2"
  if eval "(( $_que_i < 1 ))"; then
    debug "Queue '$_que' is empty."
    return $EX_ERR
  fi
  trace "Peeking a variable from queue '$_que'."
  eval "$_val=\"\${$_que[0]}\""
}


# setterm --term linux --back green --fore black --clear all
TODO "Check for 'setterm'."

###############################################################################
#                                     EOF                                     #
###############################################################################
# Basic settings
loglevel=$LL_INFO

# Setup:
PROGRAM_NAME="${BOLD}Bash me${RESET}"
VERSION="${FG_GREEN}v0.1${RESET}"
YEAR=2018
FULL_NAME="Raphael Emberger"
LICENCE="MIT License

Copyright (c) $YEAR $FULL_NAME

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \"Software\"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE."
EXPLANATION='Provides nice features for bash scripting.'
USAGE=(
  '[OPTION]...    Execute script with arguments.'
  '               Show this help page.'
)
define_opt '_log'  '-l' ''         'n'    "Log level ${ITALIC}n${RESET}."
define_opt '_help' '-h' '--help'   ''     'Display this help text.'
define_opt '_ver'  '-v' ''         ''     'Display the VERSION.'
define_opt '_file' ''   '--output' 'file' "Write log to ${ITALIC}file${RESET}(defaults to $logfile)."
DESCRIPTION="
This is an example configuration to use the Bash-me script.
You can add a licence if you want."

# Parse arguments
parse_args "$@"

# Process options
[[ -n "$_help" ]] || [[ -z ${BASH_ARGC[@]} ]] && print_usage && exit
[[ -n "$_log" ]] && loglevel="$_log"
[[ -n "$_ver" ]] && print_version && exit
[[ -n "$_file" ]] && logfile="$_file"
[[ -n "${args[@]}" ]] && IFS=";" && info "Provided additional arguments: '${args[*]}'"

# Setup traps
sig_err() {
  error "Well, I guess something went wrong."
  exit;
}
sig_int() {
  error "Bye bye."
  exit;
}
traps+=(WINCH)
trap_signals
sig_winch() {
  echo "Changed window size: $COLUMNS $ROWS"
}

# ... Code ...
loglevel=$LL_TRACE

IFS=";"
declare_queue queue
echo "Stack: '${queue[*]}', Index: '$queue_i'."
offer queue "Test"
echo "Stack: '${queue[*]}', Index: '$queue_i'."
offer queue "another string"
echo "Stack: '${queue[*]}', Index: '$queue_i'."
peeq queue value
echo "    Peeked: $value"
echo "Stack: '${queue[*]}', Index: '$queue_i'."
poll queue value
echo "    Popped: $value"
echo "Stack: '${queue[*]}', Index: '$queue_i'."
poll queue value
echo "    Popped: $value"
echo "Stack: '${queue[*]}', Index: '$queue_i'."