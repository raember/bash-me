#!/bin/bash -
#==============================================================================
#title          :bashme.sh
#description    :A bash template which manages vital mechanisms for bash
#                scripting.
#author         :Raphael Emberger
#date           :20180612
#VERSION        :0.1    
#USAGE          :./bashme.sh
#notes          :
#bash_version   :4.4.12(1)-release
#==============================================================================



###############################################################################
#                                  LOGGING                                    #
###############################################################################
# Constants
declare -ri LL_TRACE=0
declare -ri LL_DEBUG=1
declare -ri LL_INFO=2
declare -ri LL_WARN=3
declare -ri LL_ERROR=4
declare -ri LL_FATAL=5
declare -ri LL_QUIET=6

# Variables
declare -i loglevel=$LL_INFO
declare logfile="./$(basename "$0").log"
declare log2file=''
declare log2std=1

##
# Logs a message according to its log level.
# Globals:
#   BASH_LINENO
#   FUNCNAME
#   BASH_SOURCE
#   LL_ERROR
#   fnt_reset
#   log2std
#   log2file
#   logfile
# Arguments:
#   Color
#   Log level
#   Literal log level
#   Log message
# Returns:
#   None
#
function log() {
  local lineno="${BASH_LINENO[$((${#BASH_LINENO} - 1))]}"
  local location=" ${FUNCNAME[2]}(): "
  local logmsg="$(date '+%Y-%M-%d %H:%m:%S') $3($lineno)$location$4"
  if [[ -n "$log2std" ]]; then
    if (( $2 >= $LL_ERROR )); then
      echo -e "$1$logmsg$fnt_reset" >&2
    else
      echo -e "$1$logmsg$fnt_reset"
    fi
  fi
  [[ -n "$log2file" ]] && echo "$logmsg" >> $logfile
  return $EX_OK
}

##
# Logs a message on the trace level.
# Globals:
#   LL_TRACE
#   loglevel
#   fg_light_gray
#   fnt_dim
# Arguments:
#   Log message
# Returns:
#   None
#
function trace() {
  [[ $loglevel -gt $LL_TRACE ]] && return $EX_OK
  log "$fg_light_gray$fnt_dim" $LL_TRACE '[TRACE]' "$1"
  return $EX_OK
}

##
# Logs a message on the debug level.
# Globals:
#   LL_DEBUG
#   loglevel
#   fg_light_gray
# Arguments:
#   Log message
# Returns:
#   None
#
function debug() {
  [[ $loglevel -gt $LL_DEBUG ]] && return $EX_OK
  log "$fg_light_gray" $LL_DEBUG '[DEBUG]' "$1"
  return $EX_OK
}

##
# Logs a message on the info level.
# Globals:
#   LL_INFO
#   loglevel
#   fg_default
# Arguments:
#   Log message
# Returns:
#   None
#
function info() {
  [[ $loglevel -gt $LL_INFO ]] && return $EX_OK
  log "$fg_default" $LL_INFO '[INFO] ' "$1"
  return $EX_OK
}

##
# Logs a message on the warn level.
# Globals:
#   LL_WARN
#   loglevel
#   fg_yellow
# Arguments:
#   Log message
# Returns:
#   None
#
function warn() {
  [[ $loglevel -gt $LL_WARN ]] && return $EX_OK
  log "$fg_yellow" $LL_WARN '[WARN] ' "$1"
  return $EX_OK
}

##
# Logs a message on the error level.
# Globals:
#   LL_ERROR
#   loglevel
#   fg_red
# Arguments:
#   Log message
# Returns:
#   None
#
function error() {
  [[ $loglevel -gt $LL_ERROR ]] && return $EX_OK
  log "$fg_red" $LL_ERROR '[ERROR]' "$1"
  return $EX_OK
}

##
# Logs a message on the fatal level.
# Globals:
#   LL_FATAL
#   loglevel
#   fg_red
# Arguments:
#   Log message
# Returns:
#   None
#
function fatal() {
  [[ $loglevel -gt $LL_FATAL ]] && return $EX_OK
  log "$fg_light_red$fnt_bold" $LL_FATAL '[FATAL]' "$1"
  return $EX_OK
}

##
# A makeshift function to cover logging the access to not yet implemented.
# functionality.
# Globals:
#   LL_FATAL
#   loglevel
#   fg_light_red
#   fnt_bold
# Arguments:
#   None
# Returns:
#   None
#
function NYI() {
  fatal "Not implemented yet!"
  return $EX_OK
}

##
# Marks a position in the code as a TODO.
# Globals:
#   LL_INFO
#   loglevel
#   fg_green
#   fnt_bold
# Arguments:
#   The description of the work to be done.
# Returns:
#   None
#
function TODO() {
  function log_todo() {
    [[ $loglevel -gt $LL_INFO ]] && return $EX_OK
    log "$fg_green$fnt_bold" $LL_INFO '[TODO]' "$1"
    return $EX_OK
  }
  log_todo "$1"
  return $EX_OK
}



###############################################################################
#                                RETURN VALUE                                 #
###############################################################################
# Constants
declare -ri EX_OK=0
declare -ri EX_ERR=1
declare -ri EX_MISSUSE=2
declare -ri EX_CANNOTEXEC=126
declare -ri EX_CMDNOTFOUND=127
declare -ri EX_INVALARG=128
declare -ri EX_FATAL_BASE=128
declare -ri EX_INT=130
declare -ri EX_OUTOFRANGE=255

##
# Checks the last return value and writes logs.
# Globals:
#   None
# Arguments:
#   Last return value ($?)
# Returns:
#   Last return value ($?)
#
function check_retval() {
  trace "Checking return value: $1"
  local retval="$1"
  local excode="return value $retval: "
  if [[ $retval -gt 64 ]] && [[ $retval -lt 114 ]]; then
    debug "${excode}Custom C/C++ return code according to /usr/include/sysexits.h detected."
  fi
  if [[ $retval -gt 128 ]] && [[ $retval -lt 166 ]]; then
    debug "${excode}Custom fatal return value detected."
  fi
  case $retval in
    $EX_OK)
      debug "${excode}Code exited normally."
      ;;
    $EX_ERR)
      debug "${excode}Catchall for general errors. Miscellaneous errors, such as 'divide by zero' and other impermissible operations."
      ;;
    $EX_MISSUSE)
      debug "${excode}Misuse of shell builtins. Missing keyword or command or permission problem."
      ;;
    $EX_CANNOTEXEC)
      debug "${excode}Command invoked cannot execute. Permission problem or command is not an executable."
      ;;
    $EX_CMDNOTFOUND)
      debug "${excode}Command not found. Possible problem with \$PATH or a typo."
      ;;
    $EX_INVALARG)
      debug "${excode}Invalid argument to exit. exit takes only integer args in the range 0 - 255."
      ;;
    $EX_INT)
      debug "${excode}Command terminated by Control-C."
      ;;
    $EX_OUTOFRANGE)
      debug "${excode}Exit status out of range. exit takes only integer args in the range 0 - 255."
      ;;
    ?)
      warn "Could not categorize return value $retval appropriately."
  esac
  return $retval
}




###############################################################################
#                            COLORS AND FORMATTING                            #
###############################################################################
# Constants
readonly fg_default='\033[39m'
readonly fg_black='\033[30m'
readonly fg_red='\033[31m'
readonly fg_green='\033[32m'
readonly fg_yellow='\033[33m'
readonly fg_blue='\033[34m'
readonly fg_magenta='\033[35m'
readonly fg_cyan='\033[36m'
readonly fg_light_gray='\033[37m'
readonly fg_dark_gray='\033[90m'
readonly fg_light_red='\033[91m'
readonly fg_light_green='\033[92m'
readonly fg_light_yellow='\033[93m'
readonly fg_light_blue='\033[94m'
readonly fg_light_magenta='\033[95m'
readonly fg_light_cyan='\033[96m'
readonly fg_white='\033[97m'

readonly bg_default='\033[49m'
readonly bg_black='\033[40m'
readonly bg_red='\033[41m'
readonly bg_green='\033[42m'
readonly bg_yellow='\033[43m'
readonly bg_blue='\033[44m'
readonly bg_magenta='\033[45m'
readonly bg_cyan='\033[46m'
readonly bg_light_gray='\033[47m'
readonly bg_dark_gray='\033[100m'
readonly bg_light_red='\033[101m'
readonly bg_light_green='\033[102m'
readonly bg_light_yellow='\033[103m'
readonly bg_light_blue='\033[104m'
readonly bg_light_magenta='\033[105m'
readonly bg_light_cyan='\033[106m'
readonly bg_white='\033[107m'

readonly fnt_bold='\033[1m'
readonly fnt_dim='\033[2m'
readonly fnt_italic='\033[3m'
readonly fnt_underline='\033[4m'
readonly fnt_blink='\033[5m'
readonly fnt_overline='\033[6m'
readonly fnt_reverse='\033[7m'
readonly fnt_hidden='\033[8m'
readonly fnt_strikeout='\033[9m'

readonly fnt_no_bold='\033[21m'
readonly fnt_no_dim='\033[22m'
readonly fnt_no_italic='\033[23m'
readonly fnt_no_underline='\033[24m'
readonly fnt_no_blink='\033[25m'
readonly fnt_no_overline='\033[26m'
readonly fnt_no_reverse='\033[27m'
readonly fnt_no_hidden='\033[28m'
readonly fnt_no_strikeout='\033[29m'

readonly fnt_reset='\033[0m'

##
# Prints a table of all the available formats.
# Globals:
#   fnt_bold
#   fnt_dim
#   fnt_italic
#   fnt_underline
#   fnt_blink
#   fnt_overline
#   fnt_reverse
#   fnt_hidden
#   fnt_strikeout
#   fnt_no_bold
#   fnt_no_dim
#   fnt_no_italic
#   fnt_no_underline
#   fnt_no_blink
#   fnt_no_overline
#   fnt_no_reverse
#   fnt_no_hidden
#   fnt_no_strikeout
#   fnt_reset
# Arguments:
#   None
# Returns:
#   None
#
function formatting_test() {
  trace 'Printing formatting table.'
  echo -e "Bold:      ${fnt_bold}Bold${fnt_no_bold}.      No Bold${fnt_reset}."
  echo -e "Dim:       ${fnt_dim}Dim${fnt_no_dim}.       No Dim${fnt_reset}."
  echo -e "Italic:    ${fnt_italic}Italic${fnt_no_italic}.    No Italic${fnt_reset}."
  echo -e "Underline: ${fnt_underline}Underline${fnt_no_underline}. No Underline${fnt_reset}."
  echo -e "Blink:     ${fnt_blink}Blink${fnt_no_blink}.     No Blink${fnt_reset}."
  echo -e "Overline:  ${fnt_overline}Overline${fnt_no_overline}.  No Overline${fnt_reset}."
  echo -e "Reverse:   ${fnt_reverse}Reverse${fnt_no_reverse}.   No Reverse${fnt_reset}."
  echo -e "Hidden:    ${fnt_hidden}Hidden${fnt_no_hidden}.    No Hidden${fnt_reset}."
  echo -e "Strikeout: ${fnt_strikeout}Strikeout${fnt_no_strikeout}. No Strikeout${fnt_reset}."
  return $EX_OK
}

##
# Prints a table of all the available colors.
# Globals:
#   fg_default
#   fg_black
#   fg_red
#   fg_green
#   fg_yellow
#   fg_blue
#   fg_magenta
#   fg_cyan
#   fg_light_gray
#   fg_dark_gray
#   fg_light_red
#   fg_light_green
#   fg_light_yellow
#   fg_light_blue
#   fg_light_magenta
#   fg_light_cyan
#   fg_white
#   bg_default
#   bg_black
#   bg_red
#   bg_green
#   bg_yellow
#   bg_blue
#   bg_magenta
#   bg_cyan
#   bg_light_gray
#   bg_dark_gray
#   bg_light_red
#   bg_light_green
#   bg_light_yellow
#   bg_light_blue
#   bg_light_magenta
#   bg_light_cyan
#   bg_white
#   fnt_reset
# Arguments:
#   None
# Returns:
#   None
#
function color_test() {
  trace 'Printing color table.'
  echo -e "Foreground:"
  echo -e  "fg_default:    ${fg_default}fg_default${fnt_reset}"
  echo -en "fg_black:      ${fg_black}fg_black${fnt_reset}      "
  echo -e  "fg_dark_gray:     ${fg_dark_gray}fg_dark_gray${fnt_reset}"
  echo -en "fg_red:        ${fg_red}fg_red${fnt_reset}        "
  echo -e  "fg_light_red:     ${fg_light_red}fg_light_red${fnt_reset}"
  echo -en "fg_green:      ${fg_green}fg_green${fnt_reset}      "
  echo -e  "fg_light_green:   ${fg_light_green}fg_light_green${fnt_reset}"
  echo -en "fg_yellow:     ${fg_yellow}fg_yellow${fnt_reset}     "
  echo -e  "fg_light_yellow : ${fg_light_yellow}fg_light_yellow${fnt_reset}"
  echo -en "fg_blue:       ${fg_blue}fg_blue${fnt_reset}       "
  echo -e  "fg_light_blue:    ${fg_light_blue}fg_light_blue${fnt_reset}"
  echo -en "fg_magenta:    ${fg_magenta}fg_magenta${fnt_reset}    "
  echo -e  "fg_light_magenta: ${fg_light_magenta}fg_light_magenta${fnt_reset}"
  echo -en "fg_cyan:       ${fg_cyan}fg_cyan${fnt_reset}       "
  echo -e  "fg_light_cyan:    ${fg_light_cyan}fg_light_cyan${fnt_reset}"
  echo -en "fg_light_gray: ${fg_light_gray}fg_light_gray${fnt_reset} "
  echo -e  "fg_white:         ${fg_white}fg_white${fnt_reset}"
  echo -e "Background:"
  echo -e  "bg_default:    ${bg_default}bg_default${fnt_reset}"
  echo -en "bg_black:      ${bg_black}bg_black${fnt_reset}      "
  echo -e  "bg_dark_gray:     ${bg_dark_gray}bg_dark_gray${fnt_reset}"
  echo -en "bg_red:        ${bg_red}bg_red${fnt_reset}        "
  echo -e  "bg_light_red:     ${bg_light_red}bg_light_red${fnt_reset}"
  echo -en "bg_green:      ${bg_green}bg_green${fnt_reset}      "
  echo -e  "bg_light_green:   ${bg_light_green}bg_light_green${fnt_reset}"
  echo -en "bg_yellow:     ${bg_yellow}bg_yellow${fnt_reset}     "
  echo -e  "bg_light_yellow : ${bg_light_yellow}bg_light_yellow${fnt_reset}"
  echo -en "bg_blue:       ${bg_blue}bg_blue${fnt_reset}       "
  echo -e  "bg_light_blue:    ${bg_light_blue}bg_light_blue${fnt_reset}"
  echo -en "bg_magenta:    ${bg_magenta}bg_magenta${fnt_reset}    "
  echo -e  "bg_light_magenta: ${bg_light_magenta}bg_light_magenta${fnt_reset}"
  echo -en "bg_cyan:       ${bg_cyan}bg_cyan${fnt_reset}       "
  echo -e  "bg_light_cyan:    ${bg_light_cyan}bg_light_cyan${fnt_reset}"
  echo -en "bg_light_gray: ${bg_light_gray}bg_light_gray${fnt_reset} "
  echo -e  "bg_white:         ${bg_white}bg_white${fnt_reset}"
  return $EX_OK
}



###############################################################################
#                               SIGNAL TRAPPING                               #
###############################################################################
# Variables
declare -a traps=(
  ERR
  INT
)
sig_err() { exit; }
sig_int() { exit; }
sig_debug() { return; }


##
# Trap a signal or release it.
# Globals:
#   None
# Arguments:
#   Signal NAME(case or "SIG"-prefix irrelevant)
#   Callback function(Or "-" to release the signal from the trap)
# Returns:
#   Success/Failure
#
function trap_sig() {
  local -u sig="$1"
  sig="${1/SIG/}"
  if [[ "$2" = "-" ]]; then
    trace "Removing trap of signal 'SIG$sig'."
    if ! trap "-" "$sig"; then
      warn 'Could not release signal.'
      return $EX_ERR
    fi
  else
    local -l callback="sig_$sig"
    callback="${callback/+/_}"
    callback="${callback/-/_}"
    local delegate=$(cat <<EOF
          $2
          if type $callback &> /dev/null; then
            trace "Calling callback function '$callback()'."
            $callback $cb_arg
          else
            error "Callback function '$callback()' not defined."
          fi
EOF
    )
    trace "Trapping 'SIG$sig'. Callback: $callback()."
    if ! trap "$delegate" "$sig"; then
      warn 'Could not trap signal.'
      return $EX_ERR
    fi
  fi
  return $EX_OK
}

##
# Traps all the signals specified in the traps-array.
# Globals:
#   traps
#   BASH_REMATCH
# Arguments:
#   None
# Returns:
#   Success/Failure
#
function trap_signals() {
  trace 'Trapping signals.'
  local -u sig
  for sig in "${traps[@]}"; do
    case $sig in
      EXIT)
        trap_sig EXIT 'info "Exiting script. Cleaning up."'
        ;;
      ERR)
        trap_sig ERR 'errcode=$?; error "An Error occurred: $errcode"; check_retval $errcode'
        ;;
      DEBUG)
        trap_sig DEBUG 'info "Debugging."'
        ;;
      RETURN)
        trap_sig RETURN 'info "Returning from sourced script."'
        ;;
      HUP)
        trap_sig HUP 'fatal "Hangup. The controlling terminal closed."'
        ;;
      INT)
        trap_sig INT 'printf "\033[2D"; info "Terminal interrupt signal. User wishes to ${fnt_bold}interrupt${fnt_no_bold} the process."'
        ;;
      QUIT)
        trap_sig QUIT 'info "Terminal quit signal. User requests that the process ${fnt_bold}quits${fnt_no_bold} and performs a core dump."'
        ;;
      ILL)
        trap_sig ILL 'error "Illegal Instruction: Process attempted to execute an illegal, malformed, unknown, or privileged instruction."'
        ;;
      TRAP)
        trap_sig TRAP 'info "Trace/breakpoint trap. An exception (or ${fnt_bold}trap${fnt_no_bold}) occured."'
        ;;
      ABRT)
        trap_sig ABRT 'warn "Process abort signal. Got told to ${fnt_bold}abort${fnt_no_bold}/terminate."'
        ;;
      BUS)
        trap_sig BUS 'error "Access to an undefined portion of a memory object."'
        ;;
      BUS)
        trap_sig FPE 'error "Floating-point exception. Erroneous arithmetic operation."'
        ;;
      USR1)
        trap_sig USR1 'info "USR1 received. User-defined condition."'
        ;;
      USR2)
        trap_sig USR2 'info "USR2 received. User-defined condition."'
        ;;
      SEGV)
        trap_sig SEGV 'error "Segmentation violation. Invalid virtual memory reference(segmentation fault)."'
        ;;
      PIPE)
        trap_sig PIPE 'error "Process attempted to write to a pipe without a process connected to the other end."'
        ;;
      ALRM|VTALRM|PROF)
        trap_sig ALRM 'info "The time limit specified in a call to a preceding ${fnt_bold}alarm${fnt_no_bold} setting function (such as \"setitimer\") has elapsed."'
        ;;
      TERM)
        trap_sig TERM 'info "Process ${fnt_bold}termination${fnt_no_bold} requested."'
        ;;
      STKFLT)
        trap_sig STKFLT 'error "Stack fault. (i.e. popping when the stack is empty or pushing when it is full)."'
        ;;
      CHLD)
        trap_sig CHLD 'info "Child process terminated/interrupted/resumed."'
        ;;
      CONT)
        trap_sig CONT 'info "Continuing execution."'
        ;;
      STOP|TSTP)
        trap_sig STOP 'printf "\033[2D"; info "Stopping execution."'
        ;;
      TTIN)
        trap_sig TTIN 'trace "Attempting to read in from the ${fnt_bold}tty${fnt_no_bold} while in the background."'
        ;;
      TTOU)
        trap_sig TTOU 'trace "Attempting to read out from the ${fnt_bold}tty${fnt_no_bold} while in the background."'
        ;;
      URG)
        trap_sig URG 'info "A socket has urgent or out-of-band data available to read."'
        ;;
      XCPU)
        trap_sig XCPU 'fatal "CPU time limit exceeded."'
        ;;
      XFSZ)
        trap_sig XFSZ 'fatal "File size limit exceeded."'
        ;;
      WINCH)
        trap_sig WINCH 'info "Controlling terminal changed its size."'
        ;;
      POLL)
        trap_sig POLL 'info "An event occurred on an explicitly watched file descriptor."'
        ;;
      PWR)
        trap_sig PWR 'fatal "The system experiences a power failure."'
        ;;
      SYS)
        trap_sig SYS 'error "The process passed a bad argument to a system call."'
        ;;
      RTMIN*)
        local -i num
        if [[ $sig =~ ^RTMIN\+([1-9]([0-5]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMIN$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MIN $num.\""
        ;;
      RTMAX*)
        local -i num
        if [[ $sig =~ ^RTMAX\-([1-9]([0-4]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMAX$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MAX $num.\""
        ;;
      *)
        debug "Signal 'SIG$sig' unknown. Trying to trap anyway."
        trap_sig "$sig" 'trace "Recieved "SIG$sig" signal."'
        ;;
    esac
  done
  return $EX_OK
}



###############################################################################
#                               OPTION PARSING                                #
###############################################################################
# Variables
declare -a opts_var=()
declare -a opts_short=()
declare -a opts_long=()
declare -a opts_arg=()
declare -a opts_help=()
declare -i max_len_long=0
declare -i max_len_arg=0
declare -a args=()
declare NAME
declare VERSION
declare USAGE
declare -a SYNTAX
declare DESCRIPTION

##
# Defines an option to be parsed for and to put into the help page.
# Globals:
#   opts_var
#   opts_short
#   opts_long
#   opts_arg
#   opts_help
#   max_len_long
#   max_len_arg
# Arguments:
#   The variable to set
#   The short command(optional)
#   The long command(optional)
#   The argument of the option(optional)
#   The description of the option
# Returns:
#   None
#
define_opt() {
  debug "Defining option '$1'. Short: '$2'. Long: '$3'. Argument: '$4'."
  opts_var+=("$1")
  opts_short+=("$2")
  opts_long+=("$3")
  opts_arg+=("$4")
  opts_help+=("$5")
  max_len_long="$((${#3} > max_len_long ? ${#3} : max_len_long))"
  max_len_arg="$((${#4} > max_len_arg ? ${#4} : max_len_arg))"
}

##
# Parses the specified options from the script arguments.
# Globals:
#   BASH_REMATCH
#   opts_var
#   opts_short
#   opts_long
#   opts_arg
#   opts_help
#   args
# Arguments:
#   The script arguments ($@)
# Returns:
#   None
#
function parse_args() {
  # Define helper functions
  function find_matching_opt() {
    trace "Matching '$opt_str' against the defined options."
    for index in "${!opts_short[@]}"; do
      local short="${opts_short[$index]}"
      local long="${opts_long[$index]}"
      # Fix matching of no such option defined:
      [[ -z "$long" ]] && long="#"
      [[ -z "$short" ]] && short="#"
      if [[ $opt_str =~ ^\s*($short|$long)(.*)$ ]]; then
        opt="${BASH_REMATCH[1]}"
        opt_str="${BASH_REMATCH[2]}"
        trace "Found '$opt' at index $index. Remaining string: '$opt_str'"
        return $EX_OK
      fi
    done
    trace 'No match found.'
    return $EX_ERR
  }
  function expects_argument() {
    trace "Checking if an argument is expected."
    if [[ -n "${opts_arg[$index]}" ]]; then
      trace "Argument '${opts_arg[$index]}' expected."
      return $EX_OK
    fi
    trace 'No argument expected.'
    return $EX_ERR
  }
  function set_option_variable() {
    trace "Set argument for '${opts_var[$index]}'."
    local val="$1"
    if [[ -z "$val" ]]; then
      if [[ ! $opt =~ ^\s*(${opts_short[$index]}|${opts_long[$index]})\s*(.*)$ ]]; then
        fatal "Could not match '$opt' with the selected option."
      fi
      val="${BASH_REMATCH[2]}"
    fi
    local var="${opts_var[$index]}"
    debug "Set '$var' to '$val'"
    eval "$var=\"$val\""
    return $EX_OK
  }
  function arg_left_in_opt_str() {
    trace 'Checking if the required argument is in the remaining string.'
    if [[ -z "$opt_str" ]]; then
      trace 'No remaining argument in string.'
      return $EX_ERR
    fi
    trace "Found '$opt_str'."
    return $EX_OK
  }
  function find_index() {
    trace "Finding index to option '$opt'."
    for index in "${!opts_short[@]}"; do
      local short="${opts_short[$index]}"
      local long="${opts_long[$index]}"
      if [[ $opt =~ ^\s*($short|$long)$ ]]; then
        trace "Found option at index $index."
        return $EX_OK
      fi
    done
    warn 'Did not find index.'
    return $EX_ERR
  }

  # Do it
  trace "Parsing options."
  local -a args_old=("$@")
  local opt_str
  local last_opt
  for opt_str in "$@"; do
    trace "Checking string '$opt_str'."
    if [[ -n "$last_opt" ]]; then
      trace "Deduced to be argument for '$last_opt'."
      opt="$last_opt"
      last_opt=""
      find_index
      set_option_variable "$opt_str"
      continue
    fi
    local -i index
    local opt=""
    local ignore=""
    # Does the string start with an option?
    while find_matching_opt; do
      if expects_argument; then
        if arg_left_in_opt_str; then
          set_option_variable "$opt_str"
          ignore=true
          break
        else
          set_option_variable true
          last_opt="$opt"
          break
        fi
      else
        # Not an argument but might be another option
        set_option_variable true
        opt_str="-$opt_str"
        ignore=true
      fi
    done
    # No more options in the current opt_str
    if [[ -z "$ignore" ]] && [[ -n "$opt_str" ]]; then
      debug "Adding '$opt_str' to 'args'."
      args+=("$opt_str")
    fi
  done
  trace "Done parsing options."
  return $EX_OK
}

##
# Prints the VERSION of the script.
# Globals:
#   NAME
#   USAGE
#   SYNTAX
#   VERSION
#   DESCRIPTION
#   opts_var
#   opts_short
#   opts_long
#   opts_arg
#   opts_help
#   max_len_long
#   max_len_arg
# Arguments:
#   None
# Returns:
#   None
#
function print_usage() {
  trace "Printing USAGE."
  function pad_right() {
    local -i len=$1
    local str="$2"
    local str="$2"
    printf "%*s" "$((len - ${#str}))" "$pad"
    printf '%s' "$str"
  }
  function pad_left() {
    local -i len=$1
    local str="$2"
    printf '%s' "$str"
    printf "%*.${len}s" "$((len - ${#str}))" "$pad"
  }
  echo "$NAME -- $VERSION"
  echo -n 'Usage: '
  local syn
  for syn in "${SYNTAX[@]}"; do
    echo "$(basename $0) $syn"
    echo -n '       '
  done
  echo -en '\033[7D' # Override the spaces
  echo "$USAGE"
  echo
  local -i index
  for index in "${!opts_help[@]}"; do
    local short="${opts_short[$index]}"
    local long="${opts_long[$index]}"
    local argument="${opts_arg[$index]}"
    local helptext="${opts_help[$index]}"
    if [[ -n "$short" ]]; then
      if [[ -n "$long" ]]; then
        pad_right 6 "$short, "
      else
        pad_right 6 "$short  "
      fi
    else
      pad_right 6
    fi
    pad_left "$((max_len_long + 1))" "$long"
    pad_left "$((max_len_arg + 2))" "$argument"
    printf '%s' "$helptext"
    echo
  done
  echo
  echo "$DESCRIPTION"
  return $EX_OK
}

##
# Prints the VERSION of the script.
# Globals:
#   NAME
#   VERSION
# Arguments:
#   None
# Returns:
#   None
#
function print_version() {
  echo "$NAME version $VERSION"
}


# setterm --term linux --back green --fore black --clear all
TODO "Check for 'setterm'."

###############################################################################
#                                     EOF                                     #
###############################################################################
# Basic settings
loglevel=$LL_INFO

# Setup:
NAME='Bash me'
VERSION='v0.1'
USAGE='Provides nice features for bash scripting.'
SYNTAX=(
  '[OPTION]...    Execute script with arguments.'
)
define_opt '_log' '-l' '' 'n' 'Log level n.'
define_opt '_help' '-h' '--help' '' 'Display this help text.'
define_opt '_ver' '-v' '' '' 'Display the VERSION.'
define_opt '_file' '' '--output' 'file' "Write log to file(defaults to $logfile)."
DESCRIPTION=$(cat <<EOF
This is an example configuration to use the Bash-me script.
You can add a licence if you want.
EOF
)

# Parse arguments
parse_args "$@"

# Process options
[[ -n "$_help" ]] || [[ -z ${BASH_ARGC[@]} ]] && print_usage && exit
[[ -n "$_log" ]] && loglevel="$_log"
[[ -n "$_ver" ]] && print_version && exit
[[ -n "$_file" ]] && logfile="$_file"
[[ -n "${args[@]}" ]] && IFS=";" && info "Provided additional arguments: '${args[*]}'"

# Setup traps
sig_err() {
  error "Well, I guess something went wrong."
  exit;
}
sig_int() {
  error "Bye bye."
  exit;
}
trap_signals

# ... Code ...