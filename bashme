#!/bin/bash -
#==============================================================================
#title          :bashme.sh
#description    :A bash template which manages vital mechanisms for bash
#                scripting.
#author         :Raphael Emberger
#date           :20180612
#version        :0.1    
#usage          :./bashme.sh
#notes          :
#bash_version   :4.4.12(1)-release
#==============================================================================



###############################################################################
#                                  LOGGING                                    #
###############################################################################
# Constants
declare -ri LL_TRACE=0
declare -ri LL_DEBUG=1
declare -ri LL_INFO=2
declare -ri LL_WARN=3
declare -ri LL_ERROR=4
declare -ri LL_FATAL=5
declare -ri LL_QUIET=6

# Variables
declare -i loglevel=$LL_INFO
declare logfile="./$(command -p basename "$0").log"
declare log2file=''

##
# Logs a message according to its log level.
# Globals:
#   BASH_LINENO
#   FUNCNAME
#   BASH_SOURCE
#   EX_OK
#   fnt_reset
#   log2file
#   logfile
# Arguments:
#   Color
#   Log level
#   Literal log level
#   Log message
# Returns:
#   None
#
function log() {
  local index="${BASH_LINENO[$((${#BASH_LINENO} - 1))]}"
  local IFS='-'
  local location=" ${FUNCNAME[2]}(): "
  local logmsg="$(command -p date '+%Y-%M-%d %H:%m:%S') $3($lineno)$location$4"
  if (( $2 >= $LL_ERROR )); then
    command -p echo -e "\033[s$1$logmsg$fnt_reset\033[u\033[1B" >&2
  else
    command -p echo -e "\033[s$1$logmsg$fnt_reset\033[u\033[1B"
  fi
  [[ -n "$log2file" ]] && echo "$logmsg" >> $logfile
  return $EX_OK
}

##
# Logs a message on the trace level.
# Globals:
#   LL_TRACE
#   loglevel
#   fg_light_gray
# Arguments:
#   Log message
# Returns:
#   None
#
function trace() {
  [[ $loglevel -gt $LL_TRACE ]] && return $EX_OK
  log "$fg_light_gray" $LL_TRACE '[TRACE]' "$1"
  return $EX_OK
}

##
# Logs a message on the debug level.
# Globals:
#   LL_DEBUG
#   loglevel
#   fg_light_gray
# Arguments:
#   Log message
# Returns:
#   None
#
function debug() {
  [[ $loglevel -gt $LL_DEBUG ]] && return $EX_OK
  log "$fg_light_gray" $LL_DEBUG '[DEBUG]' "$1"
  return $EX_OK
}

##
# Logs a message on the info level.
# Globals:
#   LL_INFO
#   loglevel
#   fg_default
# Arguments:
#   Log message
# Returns:
#   None
#
function info() {
  [[ $loglevel -gt $LL_INFO ]] && return $EX_OK
  log "$fg_default" $LL_INFO '[INFO] ' "$1"
  return $EX_OK
}

##
# Logs a message on the warn level.
# Globals:
#   LL_WARN
#   loglevel
#   fg_yellow
# Arguments:
#   Log message
# Returns:
#   None
#
function warn() {
  [[ $loglevel -gt $LL_WARN ]] && return $EX_OK
  log "$fg_yellow" $LL_WARN '[WARN] ' "$1"
  return $EX_OK
}

##
# Logs a message on the error level.
# Globals:
#   LL_ERROR
#   loglevel
#   fg_light_red
# Arguments:
#   Log message
# Returns:
#   None
#
function error() {
  [[ $loglevel -gt $LL_ERROR ]] && return $EX_OK
  log "$fg_light_red" $LL_ERROR '[ERROR]' "$1"
  return $EX_OK
}

##
# Logs a message on the fatal level.
# Globals:
#   LL_FATAL
#   loglevel
#   fg_red
# Arguments:
#   Log message
# Returns:
#   None
#
function fatal() {
  [[ $loglevel -gt $LL_FATAL ]] && return $EX_OK
  log "$fg_red" $LL_FATAL '[FATAL]' "$1"
  return $EX_OK
}



###############################################################################
#                                RETURN VALUE                                 #
###############################################################################
# Constants
declare -ri EX_OK=0
declare -ri EX_ERR=1
declare -ri EX_MISSUSE=2
declare -ri EX_CANNOTEXEC=126
declare -ri EX_CMDNOTFOUND=127
declare -ri EX_INVALARG=128
declare -ri EX_FATAL_BASE=128
declare -ri EX_INT=130
declare -ri EX_OUTOFRANGE=255

##
# Checks the last return value and writes logs.
# Globals:
#   None
# Arguments:
#   Last return value ($?)
# Returns:
#   Last return value ($?)
#
function check_retval() {
  trace "Checking return value: $1"
  local retval="$1"
  local excode="return value $retval: "
  if [[ $retval -gt 64 ]] && [[ $retval -lt 114 ]]; then
    debug "${excode}Custom C/C++ return code according to /usr/include/sysexits.h detected."
  fi
  if [[ $retval -gt 128 ]] && [[ $retval -lt 166 ]]; then
    debug "${excode}Custom fatal return value detected."
  fi
  case $retval in
    $EX_OK)
      debug "${excode}Code exited normally."
      ;;
    $EX_ERR)
      debug "${excode}Catchall for general errors. Miscellaneous errors, such as 'divide by zero' and other impermissible operations."
      ;;
    $EX_MISSUSE)
      debug "${excode}Misuse of shell builtins. Missing keyword or command or permission problem."
      ;;
    $EX_CANNOTEXEC)
      debug "${excode}Command invoked cannot execute. Permission problem or command is not an executable."
      ;;
    $EX_CMDNOTFOUND)
      debug "${excode}Command not found. Possible problem with \$PATH or a typo."
      ;;
    $EX_INVALARG)
      debug "${excode}Invalid argument to exit. exit takes only integer args in the range 0 - 255."
      ;;
    $EX_INT)
      debug "${excode}Script terminated by Control-C."
      ;;
    $EX_OUTOFRANGE)
      debug "${excode}Exit status out of range. exit takes only integer args in the range 0 - 255."
      ;;
    ?)
      warn "Could not categorize return value $retval appropriately."
  esac
  return $retval
}




###############################################################################
#                            COLORS AND FORMATTING                            #
###############################################################################
# Constants
readonly fg_default='\033[39m'
readonly fg_black='\033[30m'
readonly fg_red='\033[31m'
readonly fg_green='\033[32m'
readonly fg_yellow='\033[33m'
readonly fg_blue='\033[34m'
readonly fg_magenta='\033[35m'
readonly fg_cyan='\033[36m'
readonly fg_light_gray='\033[37m'
readonly fg_dark_gray='\033[90m'
readonly fg_light_red='\033[91m'
readonly fg_light_green='\033[92m'
readonly fg_light_yellow='\033[93m'
readonly fg_light_blue='\033[94m'
readonly fg_light_magenta='\033[95m'
readonly fg_light_cyan='\033[96m'
readonly fg_white='\033[97m'

readonly bg_default='\033[49m'
readonly bg_black='\033[40m'
readonly bg_red='\033[41m'
readonly bg_green='\033[42m'
readonly bg_yellow='\033[43m'
readonly bg_blue='\033[44m'
readonly bg_magenta='\033[45m'
readonly bg_cyan='\033[46m'
readonly bg_light_gray='\033[47m'
readonly bg_dark_gray='\033[100m'
readonly bg_light_red='\033[101m'
readonly bg_light_green='\033[102m'
readonly bg_light_yellow='\033[103m'
readonly bg_light_blue='\033[104m'
readonly bg_light_magenta='\033[105m'
readonly bg_light_cyan='\033[106m'
readonly bg_white='\033[107m'

readonly fnt_bold='\033[1m'
readonly fnt_dim='\033[2m'
readonly fnt_italic='\033[3m'
readonly fnt_underline='\033[4m'
readonly fnt_blink='\033[5m'
readonly fnt_overline='\033[6m'
readonly fnt_reverse='\033[7m'
readonly fnt_hidden='\033[8m'
readonly fnt_strikeout='\033[9m'

readonly fnt_no_bold='\033[21m'
readonly fnt_no_dim='\033[22m'
readonly fnt_no_italic='\033[23m'
readonly fnt_no_underline='\033[24m'
readonly fnt_no_blink='\033[25m'
readonly fnt_no_overline='\033[26m'
readonly fnt_no_reverse='\033[27m'
readonly fnt_no_hidden='\033[28m'
readonly fnt_no_strikeout='\033[29m'

readonly fnt_reset='\033[0m'

##
# Prints a color table assuming 16bit colors.
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
#
function colors_16() {
  trace 'Printing color16 table.'
  #Background
  for clbg in {40..47} {100..107} 49 ; do
    #Foreground
    for clfg in {30..37} {90..97} 39 ; do
      #Formatting
      for attr in 0 1 2 3 4 5 6 7 8 9 ; do
        #Print the result
        command -p echo -en "\e[${attr};${clbg};${clfg}m ^[${attr};${clbg};${clfg}m \e[0m"
      done
      command -p echo #Newline
    done
  done
  return $EX_OK
}



###############################################################################
#                               OPTION PARSING                                #
###############################################################################
# Constants
readonly DEFAULT_OPTS='hvql:o:'

# Variables
declare opts="$DEFAULT_OPTS"

##
# Parses the specified options from the script arguments.
# Globals:
#   opts
#   DEFAULT_OPTS
# Arguments:
#   The script arguments ($@)
# Returns:
#   None
#
function parse_opts() {
  trace "Parsing options using: '$opts'."
  if [[ $opts =~ $DEFAULT_OPTS.* ]]; then
    trace 'Old options preserved'
    local opts_new="${opts:${#DEFAULT_OPTS}:99}"
    if [[ -n "$opts_new" ]]; then
      debug "New options: '$opts_new'"
    fi
    while command -p getopts "$opts" opt; do
      case $opt in
        h|v|q|l|o)
          trace "Option '$opt' already handled."
          ;;
        *)
          debug "Checking option '$opt'"
          if [[ $opts_new =~ $opt ]]; then # Option specified
            eval "$opt=1"
            if [[ $opts_new =~ $opt: ]]; then # Argument provided
              opt_name="$opt"
              eval "$opt="${OPTARG}""
              debug "Found option '$opt_name=$opt'."
            else
              debug "Found option '$opt'."
            fi
          else
            debug "Couldn't find '$opt' in '$opts_new'."
            print_help
            exit $EX_MISSUSE
          fi
          ;;
      esac
    done
    shift $((OPTIND-1))
    trace 'Done parsing arguments.'
  else
    trace 'Old options overridden.'
  fi
  return $EX_OK
}

function print_help() {
  echo -n 'Usage: '
  for syn in "${syntax[@]}"; do
    echo "$(basename $0) $syn"
    echo -n '       '
  done
  echo -en '\033[7D'
  echo "$usage"
  echo
  for option in "${optArray[@]}"; do
    get_opt "$option"
    if [[ -n "$short" ]]; then
      echo -n "  -$short"
      if [[ -n "$long" ]]; then
        echo -n ','
      else
        echo -n ' '
      fi
    else
      echo -en '     '
    fi
    if [[ -n "$long" ]]; then
      line=" --$long"
      if [[ -n "$argument" ]]; then
        line="$line $argument"
      fi
      let "len = $maxlen - ${#line} + 1"
      echo -en "$line "
      printf ' %.0s' {1..$len}
    else
      printf ' %.0s' {1..$maxlen}
    fi
    echo -e "$descr"
  done
  return $EX_OK
}

function setup() {
  if [[ $opts =~ $DEFAULT_OPTS.* ]]; then
    # Parsing options early
    if test_option "$@" 'h'; then 
      print_help
      exit $EX_OK
    fi
    if test_option "$@" 'q'; then
      loglevel=$LL_QUIET
    elif test_option "$@" 'v'; then
      loglevel=$LL_TRACE
      debug "Set log level to $loglevel."
    elif test_option "$@" 'l\ *([0-9]*)'; then
      loglevel=${BASH_REMATCH[1]}
    fi
    if [[ $loglevel -ne $LL_QUIET ]]; then
      if test_option "$@" 'o\ +([/a-zA-Z0-9\.]+)'; then
        logfile=${BASH_REMATCH[1]}
        log2file=1
      fi
      debug "Set log level to $loglevel"
      [[ -n "$log2file" ]] && debug "Set log file to '$logfile'."
    fi
    if [[ -z "$trapping" ]]; then
      trap_signals
    fi
  fi
  parse_opts "$@"
  return $?
}

function test_option() {
  [[ \ $1 =~  \ -[a-zA-Z0-9]*$2 ]] && return $EX_OK;
  return $EX_ERR;
}


###############################################################################
#                               SIGNAL TRAPPING                               #
###############################################################################
# Variables
declare -a traps=(
  ERR
  EXIT
  INT
)

##
# Trap a signal or release it.
# Globals:
#   None
# Arguments:
#   Signal name(case or "SIG"-prefix irrelevant)
#   Callback function(Or "-" to release the signal from the trap)
# Returns:
#   Success/Failure
#
function trap_sig() {
  local -u sig="$1"
  sig="${1/SIG/}"
  if [[ "$2" = "-" ]]; then
    trace "Removing trap of signal 'SIG$sig'."
    if ! trap "-" "$sig"; then
      warn 'Could not release signal.'
      return $EX_ERR
    fi
  else
    local -l callback="sig_$sig"
    callback="${callback/+/_}"
    callback="${callback/-/_}"
    local delegate=$(cat <<EOF
          $2
          if type $callback &> /dev/null; then
            trace "Calling callback function '$callback()'."
            $callback $cb_arg
          else
            error "Callback function '$callback()' not defined."
          fi
EOF
    )
    trace "Trapping 'SIG$sig'. Callback: $callback()."
    if ! trap "$delegate" "$sig"; then
      warn 'Could not trap signal.'
      return $EX_ERR
    fi
  fi
  return $EX_OK
}

##
# Traps all the signals specified in the traps-array.
# Globals:
#   traps
#   BASH_REMATCH
# Arguments:
#   None
# Returns:
#   Success/Failure
#
function trap_signals() {
  trace 'Trapping signals.'
  local -u sig
  for sig in "${traps[@]}"; do
    case $sig in
      EXIT)
        trap_sig EXIT 'info "Exiting script. Cleaning up."'
        ;;
      ERR)
        trap_sig ERR 'error "An Error occurred: $?\n$(check_retval $?)"'
        ;;
      DEBUG)
        trap_sig DEBUG 'info "Debugging."'
        ;;
      RETURN)
        trap_sig RETURN 'info "Returning from sourced script."'
        ;;
      HUP)
        trap_sig HUP 'fatal "Hangup. The controlling terminal closed."'
        ;;
      INT)
        trap_sig INT 'printf "\033[2D"; info "Terminal interrupt signal. User wishes to ${fnt_bold}interrupt${fnt_no_bold} the process."'
        ;;
      QUIT)
        trap_sig QUIT 'info "Terminal quit signal. User requests that the process ${fnt_bold}quits${fnt_no_bold} and performs a core dump."'
        ;;
      ILL)
        trap_sig ILL 'error "Illegal Instruction: Process attempted to execute an illegal, malformed, unknown, or privileged instruction."'
        ;;
      TRAP)
        trap_sig TRAP 'info "Trace/breakpoint trap. An exception (or ${fnt_bold}trap${fnt_no_bold}) occured."'
        ;;
      ABRT)
        trap_sig ABRT 'warn "Process abort signal. Got told to ${fnt_bold}abort${fnt_no_bold}/terminate."'
        ;;
      BUS)
        trap_sig BUS 'error "Access to an undefined portion of a memory object."'
        ;;
      BUS)
        trap_sig FPE 'error "Floating-point exception. Erroneous arithmetic operation."'
        ;;
      USR1)
        trap_sig USR1 'info "USR1 received. User-defined condition."'
        ;;
      USR2)
        trap_sig USR2 'info "USR2 received. User-defined condition."'
        ;;
      SEGV)
        trap_sig SEGV 'error "Segmentation violation. Invalid virtual memory reference(segmentation fault)."'
        ;;
      PIPE)
        trap_sig PIPE 'error "Process attempted to write to a pipe without a process connected to the other end."'
        ;;
      ALRM|VTALRM|PROF)
        trap_sig ALRM 'info "The time limit specified in a call to a preceding ${fnt_bold}alarm${fnt_no_bold} setting function (such as \"setitimer\") has elapsed."'
        ;;
      TERM)
        trap_sig TERM 'info "Process ${fnt_bold}termination${fnt_no_bold} requested."'
        ;;
      STKFLT)
        trap_sig STKFLT 'error "Stack fault. (i.e. popping when the stack is empty or pushing when it is full)."'
        ;;
      CHLD)
        trap_sig CHLD 'info "Child process terminated/interrupted/resumed."'
        ;;
      CONT)
        trap_sig CONT 'info "Continuing execution."'
        ;;
      STOP|TSTP)
        trap_sig STOP 'printf "\033[2D"; info "Stopping execution."'
        ;;
      TTIN)
        trap_sig TTIN 'trace "Attempting to read in from the ${fnt_bold}tty${fnt_no_bold} while in the background."'
        ;;
      TTOU)
        trap_sig TTOU 'trace "Attempting to read out from the ${fnt_bold}tty${fnt_no_bold} while in the background."'
        ;;
      URG)
        trap_sig URG 'info "A socket has urgent or out-of-band data available to read."'
        ;;
      XCPU)
        trap_sig XCPU 'fatal "CPU time limit exceeded."'
        ;;
      XFSZ)
        trap_sig XFSZ 'fatal "File size limit exceeded."'
        ;;
      WINCH)
        trap_sig WINCH 'info "Controlling terminal changed its size."'
        ;;
      POLL)
        trap_sig POLL 'info "An event occurred on an explicitly watched file descriptor."'
        ;;
      PWR)
        trap_sig PWR 'fatal "The system experiences a power failure."'
        ;;
      SYS)
        trap_sig SYS 'error "The process passed a bad argument to a system call."'
        ;;
      RTMIN*)
        local -i num
        if [[ $sig =~ ^RTMIN\+([1-9]([0-5]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMIN$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MIN $num.\""
        ;;
      RTMAX*)
        local -i num
        if [[ $sig =~ ^RTMAX\-([1-9]([0-4]|))$ ]]; then
          num=${BASH_REMATCH[1]}
        elif [[ $sig =~ ^RTMAX$ ]]; then
          num=0
        else
          error "Signal 'SIG$sig' unknown. Cannot trap."
          continue
        fi
        trap_sig "$sig" "trace \"Received real-time signal MAX $num.\""
        ;;
      *)
        debug "Signal 'SIG$sig' unknown. Trying to trap anyway."
        trap_sig "$sig" 'trace "Recieved "SIG$sig" signal."'
        ;;
    esac
  done
  return $EX_OK
}


###############################################################################
#                                     EOF                                     #
###############################################################################

# Preamble
opts="${opts}a:"
syntax=(
  '[OPTION]...'
  '[OPTION]... [FILE]'
)
usage='Remove (unlink) the FILE(s).'
traps=(
  ERr
  EXIT
  INT
)
sig_err() { exit; }
sig_exit() { exit; }
sig_int() { exit; }
setup "$@"

# Code
sig_debug() {
    local -i row="$((${BASH_LINENO[0]} - 3))"
    local text=$(sed "${row}q;d" "$(basename $0)")
    debug "$row: $text"
    read;
}
trap_sig DEBUG ''
echo "$LINENO"
echo "$LINENO"
echo "a = $a"
if type setterm &>/dev/null; then
  read
  setterm --term linux --back green --fore black --clear all
fi
while true; do
  ls &> /dev/null
done